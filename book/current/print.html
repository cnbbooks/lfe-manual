<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js lfe-pdp">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>LFE MACHINE MANUAL</title>
    <meta name="robots" content="noindex" />


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="The Manual for the Machine that is LFE/OTP">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="css/custom.css">

</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "lfe-pdp" : "lfe-pdp";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('lfe-pdp')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item affix "><a href="index.html">LFE MACHINE MANUAL</a></li><li class="chapter-item affix "><a href="fm/title-page.html">Title Page</a></li><li class="chapter-item affix "><a href="fm/copyright.html">Copyright</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="preface/index.html">Preface</a></li><li class="chapter-item affix "><a href="preface/about-cover.html">About the Cover</a></li><li class="chapter-item affix "><a href="preface/dedication.html">Dedication</a></li><li class="chapter-item affix "><a href="preface/forward.html">Forward</a></li><li class="chapter-item affix "><a href="preface/acknowledgments.html">Acknowledgments</a></li><li class="spacer"></li><li class="chapter-item "><a href="part1/index.html"><strong aria-hidden="true">1.</strong> Part I - Getting Started</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/intro/index.html"><strong aria-hidden="true">1.1.</strong> Introduction</a></li><li class="chapter-item "><a href="part1/intro/about.html"><strong aria-hidden="true">1.2.</strong> WIP - About LFE</a></li><li class="chapter-item "><a href="part1/intro/prereq.html"><strong aria-hidden="true">1.3.</strong> Prerequisites</a></li><li class="chapter-item "><a href="part1/intro/conventions.html"><strong aria-hidden="true">1.4.</strong> Conventions</a></li><li class="chapter-item "><a href="part1/intro/setup.html"><strong aria-hidden="true">1.5.</strong> Development Setup</a></li><li class="chapter-item "><a href="part1/intro/hw/index.html"><strong aria-hidden="true">1.6.</strong> 'Hello, World!'</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/intro/hw/repl.html"><strong aria-hidden="true">1.6.1.</strong> Classic, REPL</a></li><li class="chapter-item "><a href="part1/intro/hw/main.html"><strong aria-hidden="true">1.6.2.</strong> Classic, main</a></li><li class="chapter-item "><a href="part1/intro/hw/otp.html"><strong aria-hidden="true">1.6.3.</strong> LFE/OTP</a></li></ol></li><li class="chapter-item "><a href="part1/intro/guessing-game/index.html"><strong aria-hidden="true">1.7.</strong> Walk-through: An LFE Guessing Game</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/intro/guessing-game/planning.html"><strong aria-hidden="true">1.7.1.</strong> Planning the Game</a></li><li class="chapter-item "><a href="part1/intro/guessing-game/code.html"><strong aria-hidden="true">1.7.2.</strong> Code Explore</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/intro/guessing-game/input.html"><strong aria-hidden="true">1.7.2.1.</strong> Getting User Input</a></li><li class="chapter-item "><a href="part1/intro/guessing-game/check.html"><strong aria-hidden="true">1.7.2.2.</strong> Checking the Input</a></li></ol></li><li class="chapter-item "><a href="part1/intro/guessing-game/integrate.html"><strong aria-hidden="true">1.7.3.</strong> Integrating into an Application</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/intro/guessing-game/cast.html"><strong aria-hidden="true">1.7.3.1.</strong> handle_cast</a></li><li class="chapter-item "><a href="part1/intro/guessing-game/api.html"><strong aria-hidden="true">1.7.3.2.</strong> Game API</a></li><li class="chapter-item "><a href="part1/intro/guessing-game/finishing-touches.html"><strong aria-hidden="true">1.7.3.3.</strong> Finishing Touches</a></li><li class="chapter-item "><a href="part1/intro/guessing-game/play.html"><strong aria-hidden="true">1.7.3.4.</strong> Playing the Game</a></li></ol></li><li class="chapter-item "><a href="part1/intro/guessing-game/review.html"><strong aria-hidden="true">1.7.4.</strong> WIP - Review</a></li></ol></li><li class="chapter-item "><a href="part1/repl/index.html"><strong aria-hidden="true">1.8.</strong> The LFE REPL</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/repl/features.html"><strong aria-hidden="true">1.8.1.</strong> Core Features</a></li><li class="chapter-item "><a href="part1/repl/start.html"><strong aria-hidden="true">1.8.2.</strong> Starting LFE</a></li><li class="chapter-item "><a href="part1/repl/readline.html"><strong aria-hidden="true">1.8.3.</strong> WIP - readline Support</a></li><li class="chapter-item "><a href="part1/repl/help.html"><strong aria-hidden="true">1.8.4.</strong> (help)</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/repl/help-builtins.html"><strong aria-hidden="true">1.8.4.1.</strong> REPL Functions</a></li><li class="chapter-item "><a href="part1/repl/help-cmds.html"><strong aria-hidden="true">1.8.4.2.</strong> REPL Commands</a></li><li class="chapter-item "><a href="part1/repl/help-special-vars.html"><strong aria-hidden="true">1.8.4.3.</strong> Special Variables</a></li></ol></li><li class="chapter-item "><a href="part1/repl/c.html"><strong aria-hidden="true">1.8.5.</strong> Command Interface</a></li><li class="chapter-item "><a href="part1/repl/job-control.html"><strong aria-hidden="true">1.8.6.</strong> WIP - Job Control</a></li><li class="chapter-item "><a href="part1/repl/files.html"><strong aria-hidden="true">1.8.7.</strong> Files</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.</strong> Part II - Code as Data</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part2/vars/index.html"><strong aria-hidden="true">2.1.</strong> Variables</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part2/vars/bindings.html"><strong aria-hidden="true">2.1.1.</strong> Bindings</a></li><li class="chapter-item "><a href="part2/vars/patts.html"><strong aria-hidden="true">2.1.2.</strong> Pattern-matching Preview</a></li><li class="chapter-item "><a href="part2/vars/glob-revist.html"><strong aria-hidden="true">2.1.3.</strong> Globals Revisted</a></li></ol></li><li class="chapter-item "><a href="part2/data-types/index.html"><strong aria-hidden="true">2.2.</strong> Primitive Types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part2/data-types/integers.html"><strong aria-hidden="true">2.2.1.</strong> Integers</a></li><li class="chapter-item "><a href="part2/data-types/floats.html"><strong aria-hidden="true">2.2.2.</strong> Floats</a></li><li class="chapter-item "><a href="part2/data-types/atoms.html"><strong aria-hidden="true">2.2.3.</strong> Atoms (Symbols)</a></li><li class="chapter-item "><a href="part2/data-types/bools.html"><strong aria-hidden="true">2.2.4.</strong> Booleans</a></li><li class="chapter-item "><a href="part2/data-types/chars.html"><strong aria-hidden="true">2.2.5.</strong> Characters</a></li></ol></li><li class="chapter-item "><a href="part2/data-types/index.html"><strong aria-hidden="true">2.3.</strong> Cons Cells</a></li><li class="chapter-item "><a href="part2/lists/index.html"><strong aria-hidden="true">2.4.</strong> Lists and Strings</a></li><li class="chapter-item "><a href="part2/byte-bin/index.html"><strong aria-hidden="true">2.5.</strong> Bytes and Binaries</a></li><li class="chapter-item "><a href="part2/tuples/index.html"><strong aria-hidden="true">2.6.</strong> Tuples</a></li><li class="chapter-item "><a href="part2/proplists/index.html"><strong aria-hidden="true">2.7.</strong> Property Lists</a></li><li class="chapter-item "><a href="part2/maps/index.html"><strong aria-hidden="true">2.8.</strong> Maps</a></li><li class="chapter-item "><a href="part2/arrays/index.html"><strong aria-hidden="true">2.9.</strong> Arrays</a></li><li class="chapter-item "><a href="part2/dicts/index.html"><strong aria-hidden="true">2.10.</strong> Dicts</a></li><li class="chapter-item "><a href="part2/records/index.html"><strong aria-hidden="true">2.11.</strong> Records</a></li><li class="chapter-item "><a href="part2/patterns/index.html"><strong aria-hidden="true">2.12.</strong> Pattern Matching</a></li><li class="chapter-item "><a href="part2/gen-seq/index.html"><strong aria-hidden="true">2.13.</strong> Generic Sequence Functions</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">3.</strong> Part III - Data as Code</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part3/exprs/index.html"><strong aria-hidden="true">3.1.</strong> Expressions</a></li><li class="chapter-item "><a href="part3/funs/index.html"><strong aria-hidden="true">3.2.</strong> Functions</a></li><li class="chapter-item "><a href="part3/closures/index.html"><strong aria-hidden="true">3.3.</strong> Closures</a></li><li class="chapter-item "><a href="part3/eval/index.html"><strong aria-hidden="true">3.4.</strong> Evaluation</a></li><li class="chapter-item "><a href="part3/expressioins/index.html"><strong aria-hidden="true">3.5.</strong> Expressions</a></li><li class="chapter-item "><a href="part3/processes/index.html"><strong aria-hidden="true">3.6.</strong> Processes</a></li><li class="chapter-item "><a href="part3/msgs/index.html"><strong aria-hidden="true">3.7.</strong> Messages and Their Passing</a></li><li class="chapter-item "><a href="part3/objects/index.html"><strong aria-hidden="true">3.8.</strong> Objects and Flavors</a></li><li class="chapter-item "><a href="part3/io/index.html"><strong aria-hidden="true">3.9.</strong> I/O</a></li><li class="chapter-item "><a href="part3/files/index.html"><strong aria-hidden="true">3.10.</strong> Accessing Files</a></li><li class="chapter-item "><a href="part3/modules/index.html"><strong aria-hidden="true">3.11.</strong> Modules</a></li><li class="chapter-item "><a href="part3/packages/index.html"><strong aria-hidden="true">3.12.</strong> Packages</a></li><li class="chapter-item "><a href="part3/scripting/index.html"><strong aria-hidden="true">3.13.</strong> Scripting with LFE</a></li><li class="chapter-item "><a href="part3/projects/index.html"><strong aria-hidden="true">3.14.</strong> Creating LFE Projects</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part3/projects/rebar3.html"><strong aria-hidden="true">3.14.1.</strong> Using rebar3</a></li><li class="chapter-item "><a href="part3/projects/layout.html"><strong aria-hidden="true">3.14.2.</strong> Project Layout Conventions</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.</strong> Part IV - Advanced Topics</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part4/err-debug/index.html"><strong aria-hidden="true">4.1.</strong> Errors and Debugging</a></li><li class="chapter-item "><a href="part4/unit/index.html"><strong aria-hidden="true">4.2.</strong> Writing Unit Tests</a></li><li class="chapter-item "><a href="part4/ct/index.html"><strong aria-hidden="true">4.3.</strong> The Common Test Framework</a></li><li class="chapter-item "><a href="part4/propr/index.html"><strong aria-hidden="true">4.4.</strong> The Propr Test Framework</a></li><li class="chapter-item "><a href="part4/compiler/index.html"><strong aria-hidden="true">4.5.</strong> The Compiler</a></li><li class="chapter-item "><a href="part4/macros/index.html"><strong aria-hidden="true">4.6.</strong> Macros</a></li><li class="chapter-item "><a href="part4/dist/index.html"><strong aria-hidden="true">4.7.</strong> Distributed LFE</a></li><li class="chapter-item "><a href="part4/ports/REAEDME.html"><strong aria-hidden="true">4.8.</strong> Ports and Port Drivers</a></li><li class="chapter-item "><a href="part4/servers/REAEDME.html"><strong aria-hidden="true">4.9.</strong> Servers</a></li><li class="chapter-item "><a href="part4/clients/REAEDME.html"><strong aria-hidden="true">4.10.</strong> Clients</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">5.</strong> Part V - OTP</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part5/behaviours/index.html"><strong aria-hidden="true">5.1.</strong> Behaviours</a></li><li class="chapter-item "><a href="part5/apps/index.html"><strong aria-hidden="true">5.2.</strong> Applications</a></li><li class="chapter-item "><a href="part5/rels/index.html"><strong aria-hidden="true">5.3.</strong> Releases</a></li><li class="chapter-item "><a href="part5/data/index.html"><strong aria-hidden="true">5.4.</strong> Tables and Databases</a></li><li class="chapter-item "><a href="part5/project/index.html"><strong aria-hidden="true">5.5.</strong> Example OTP Project</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">6.</strong> Part VI - Conclusion</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part6/epilogue.html"><strong aria-hidden="true">6.1.</strong> Epilogue</a></li><li class="chapter-item "><a href="part6/afterward.html"><strong aria-hidden="true">6.2.</strong> Afterword</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><a href="epilogue/glossary.html">Glossary</a></li><li class="chapter-item affix "><a href="epilogue/bibliography.html">Bibliography</a></li><li class="chapter-item affix "><a href="epilogue/index.html">Index</a></li><li class="spacer"></li><li class="chapter-item affix "><div>Appendices</div></li><li class="chapter-item affix "><a href="appendices/lisp-history.html">I - Origins Of Lisp</a></li><li class="chapter-item affix "><a href="appendices/erlang-history.html">II - Origins Of Erlang</a></li><li class="chapter-item affix "><a href="appendices/lfe-overview.html">III - Origins Of LFE</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="versions.html">Versions</a></li><li class="chapter-item affix "><a href="feedback.html">Feedback</a></li><li class="chapter-item affix "><a href="redirects/docs.html">LFE Documentation</a></li><li class="chapter-item affix "><a href="redirects/mdbook.html">Built with mdBook</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme"
                                id="lfe-pdp">LFE PDP</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="light">Light</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">LFE MACHINE MANUAL</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/cnbbooks/lfe-manual" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                        placeholder="Search this book ..." aria-controls="searchresults-outer"
                        aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <p><a href="images/cover-large.jpg"><img src="images/cover.jpg" alt="" /></a></p>
<!-- Named page links below: /-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="lfe-machine-manual"><a class="header" href="#lfe-machine-manual">LFE MACHINE MANUAL</a></h1>
<br/>
<br/>
<br/>
<br/>
<br/>
<p>Adatped from multiple sources
<br/>
by Duncan McGreggor and Robert Virding</p>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<p><a href="http://cnbb.pub/"><img src="fm/../images/cnbb-pub-logo-1.6.png" alt="publisher logo" /></a></p>
<!-- Named page links below: /-->
<div style="break-before: page; page-break-before: always;"></div><p>Published by Cowboys 'N' Beans Books</p>
<p><a href="https://github.com/cnbbooks">https://github.com/cnbbooks</a> ‚óà <a href="http://cnbb.pub/">http://cnbb.pub/</a> ‚óà <a href="mailto:info@cnbb.pub">info@cnbb.pub</a></p>
<br/>
<br/>
<br/>
<p>First electronic edition published: 2020</p>
<br/>
<br/>
<br/>
<p>Portions ¬© 1974, David Moon</p>
<p>Portions ¬© 1978-1981, Daniel Weinreb and David Moon</p>
<p>Portions ¬© 1979-1984, Douglas Adams</p>
<p>Portions ¬© 1983, Kent Pitman</p>
<p>Portions ¬© 1992-1993, Peter Norvig and Kent Pitman</p>
<p>Portions ¬© 2003-2020, Ericsson AB</p>
<p>Portions ¬© 2008-2012, Robert Virding</p>
<p>Portions ¬© 2010-2020, Steve Klabnik and Carol Nichols</p>
<p>Portions ¬© 2013-2020, Robert Virding and Duncan McGreggor</p>
<p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></p>
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="Creative Commons License" /></a></p>
<br/>
<br/>
<br/>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>The original Lisp Machine Manual, the direct spiritiaul ancestor of the LFE Machine Manual, described both the language and the &quot;operating system&quot; of the Lisp Machine. The language was a dialect of Lisp called Zetalisp. Zetalisp was a direct descendant of MACLISP, created as a systems programming language for the MIT Lisp machines. This is of special note since Erlang was created as a systems programming language too. One of it's co-creators, Robert Virding, created Lisp Flavoured Erlang (LFE) based upon his expereinces with Franz Lisp (which based largely upon MACLISP), Portable Standard Lisp (itself an experiment in systems programming), and ultimately in an implementation he made of Lisp Machine Flavors on top of VAX/VMS where he extensively utilized the Lisp Machine Manual.</p>
<p>As such, LFE has a very strong inheritance of systems programming from both parents, as it were. First and foremost, it is a BEAM language written on top of the Erlang VM and from which it strays very little. Secondly, it is a Lisp dialect. It is, however, <em>entirely</em> a systems programming language.</p>
<p>Which brings us back to Zetalisp and the Lisp Machine Manual. It seemed only fitting to base the LFE manual upon the fantastic work and docuentation that was done on Lisp systems programming in the 70s and 80s, work that so many of us treasure and adore and to which we still defer. Thus the machine that is OTP in the context and syntax of the LFE Lisp dialect is extensively documented in the LFE MACHINE MANUAL.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-the-cover"><a class="header" href="#about-the-cover">About the Cover</a></h1>
<p>The LFE &quot;Chineual&quot; cover is based upon the Lisp Machine Manual covers of the early 80s. The Lisp Machine Manual editions we have seen from 1977 and 1979 had only hand-typed title pages, no covers, so we're not sure if the famous graphic/typographic design occurred any earlier than 1982. We've also been unable to discover who the original designer was, but would love to give them credit, should we find out.</p>
<h2 id="the-original"><a class="header" href="#the-original">The Original</a></h2>
<p>The Software Preservation Group has this image on their site:</p>
<p><a href="http://www.softwarepreservation.org/projects/LISP/images/LispMachineManual.gif/view"><img src="preface/../images/chinuel-cover-bw.png" alt="" /></a></p>
<p>Bitsavers has a 3rd edition of the Chineual with the full cover</p>
<p><a href="http://www.bitsavers.org/pdf/mit/cadr/chinual_3rdEd_Mar81.pdf"><img src="preface/../images//chinuel-cover-full-color.png" alt="" /></a></p>
<h2 id="the-lfe-edition"><a class="header" href="#the-lfe-edition">The LFE Edition</a></h2>
<h3 id="whole-cover"><a class="header" href="#whole-cover">Whole Cover</a></h3>
<p><a href="preface/../images/cover-all-large.jpg"><img src="preface/../images/cover-all.jpg" alt="" /></a></p>
<h3 id="back-cover"><a class="header" href="#back-cover">Back Cover</a></h3>
<p><a href="preface/../images/cover-back-large.jpg"><img src="preface/../images/cover-back.jpg" alt="" /></a></p>
<h3 id="the-spine"><a class="header" href="#the-spine">The Spine</a></h3>
<p><a href="preface/../images/cover-binding-large.jpg"><img src="preface/../images/cover-binding.jpg" alt="" /></a></p>
<!-- Named page links below: /-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="dedication"><a class="header" href="#dedication">Dedication</a></h1>
<p>TBD</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forward"><a class="header" href="#forward">Forward</a></h1>
<p>TBD</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h1>
<p>TBD</p>
<p>[gonna be a long list ...]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-i"><a class="header" href="#part-i">PART I</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Far out in the uncharted backwaters of the unfashionable end of computer science known as &quot;distributed systems programming&quot; lies a small red <em>e</em>. Orbitting this at a distance roughly proportional to the inverse of the likelihood of it being noticed is an utterly insignificant little green mug filled with the morning beverage stimulant equivalent of That Old Janx Spirit. Upon that liquid floats a little yellow <em>ùõå</em> whose adherents are so amazingly primitive that they still think <code>cons</code>s, <code>car</code>, and <code>cdr</code> are pretty neat ideas.</p>
<p>This is their book.</p>
<p>Their language, Lisp Flavoured Erlang (henceforth &quot;LFE&quot;), lets you use the archaic and much-beloved S-expressions to write some of the most advanced software on the planet. LFE is a general-purpose, concurrent, functional Lisp whose underlying virtual machine (Erlang) was designed to create distributed, fault-tolerant, soft-realtime, highly-availale, always-up, hot-swappable appliances, applications, and services. In addition to fashionable digital watches, LFE sports immutable data, pattern-matching, eager evaluation, and dynamic typing.</p>
<p>This manual will not only teach you what all of that means and why you want it in your breakfast cereal, but also: how to create LFE programs; what exactly are the basic elements of the language; the ins-and-outs of extremely efficient and beautiful clients and servers; and much, much more.</p>
<p>Note, however, that the first chapter is a little different than most other books, and is in fact different from the rest of the chapters in this manual. We wrote this chapter with two guiding thoughts: firstly and foremost, we wanted to provide some practical examples of code-in-action as a context in which a programmer new to LFE could continuously refer -- from the very beginning through to the successful end --  while learning the general principles of that language; secondly, most programming language manuals are dry references to individual pieces of a language or system, not representatives of the whole, and we wanted to provide a starting place for those who learn well via examples, who <em>would</em> benefit from a view toward that whole. For those who have already seen plenty of LFE examples and would rather get to down to the nitty-gritty, rest assured we desire your experience to be guilt-free and thus encourage you to jump into next chapter immediately!</p>
<p>This book is divided into 6 parts with the following foci:</p>
<ul>
<li>Introductory material</li>
<li>Core data types and capabilities</li>
<li>The basics of LFE code and projects</li>
<li>Advanced language features</li>
<li>The machine that is OTP</li>
<li>Concluding thoughts and summaries</li>
</ul>
<p>There is a lot of material in this book, so just take it section by section. If at any time you feel overwhelmed, simply set down the book, take a deep breath, fix yourself a cuppa, and don't panic.</p>
<p>Welcome to the LFE MACHINE MANUAL, the definitive LFE reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-lfe"><a class="header" href="#about-lfe">About LFE</a></h1>
<h2 id="what-lfe-isnt"><a class="header" href="#what-lfe-isnt">What LFE Isn't</a></h2>
<p>Just to clear the air and set some expectations, here's what you're not going to find in LFE:</p>
<ul>
<li>An implementation of Scheme</li>
<li>An implementation of Common Lisp</li>
<li>An implementation of Clojure</li>
</ul>
<p>As such, you will not find the following:</p>
<ul>
<li>A Scheme-like single namespace</li>
<li>CL packages or munged names faking packages</li>
<li>Access to Java libraries</li>
</ul>
<h2 id="what-lfe-is"><a class="header" href="#what-lfe-is">What LFE Is!</a></h2>
<p>Here's what you can expect of LFE:</p>
<ul>
<li>A proper Lisp-2, based on the features and limitations of the Erlang VM</li>
<li>Compatibility with vanilla Erlang and OTP</li>
<li>It runs on the standard Erlang VM</li>
</ul>
<p>Furthermore, as a result of Erlang's influence (and LFE's compatibility with it), the following hold:</p>
<ul>
<li>there is no global data</li>
<li>data is not mutable</li>
<li>only the standard Erlang data types are used</li>
<li>you get pattern matching and guards</li>
<li>you have access to Erlang functions and modules</li>
<li>LFE has a compiler/interpreter</li>
<li>functions with declared arity and fixed number of arguments</li>
<li>Lisp macros</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>Anyone coming to LFE should have experience programming in another language, ideally a systems programming language, especially if that language was found lacking. If the corageous reader is attmping to use LFE as a means of entering the study of computer science, we might offer several <em>other</em> paths of study which may bear fruit more quickly and with less pain.</p>
<p>No prior Lisp experience is required, but that would certinaly be helpful. The same goes for Erlang/OTP (or any of the suite of BEAM languages). The reader with experience writing concurrent applications, wrestling with fault-tolerance, or maintaining highly-available applications and services does receive bonus points for preparedness. Such well-prepared readers landing here may have, in fact, done so due to a quest for a distributed Lisp. For those whom this does apply, your quest has found its happy end.</p>
<p>This book assumes the reader has the following installed upon their system:</p>
<ul>
<li>a package manager for easily installing software (in particular, development tools and supporting libraries)</li>
<li><code>git</code>, <code>make</code>, and other core open source software development tools</li>
<li>a modern version of Erlang (as of the writing of this book, that would include versions 19 through 23); the rebar3 documentation has <a href="https://www.rebar3.org/docs/getting-started#installing-erlang">great suggestions</a> on what to use here, depending upon your need</li>
<li>the <code>rebar3</code> build tool for Erlang (and other BEAM languages); see <a href="https://www.rebar3.org/docs/getting-started#installing-binary">its docs</a> for installation instructions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conventions"><a class="header" href="#conventions">Conventions</a></h1>
<h2 id="typography"><a class="header" href="#typography">Typography</a></h2>
<h3 id="key-entry"><a class="header" href="#key-entry">Key Entry</a></h3>
<p>We use the angle bracket convention to indicate typing actual key on the keyboard. For instance, when the reader sees <code>&lt;ENTER&gt;</code> they should interpret this as an actual key they should type. Note that all keys are given in upper-case. If the reader is expected to use an upper-case &quot;C&quot;  instead of a lower-case &quot;c&quot;, they will be presented with the key combination <code>&lt;SHIFT&gt;&lt;C&gt;</code>.</p>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<p>Color syntax highlighting is used in this text to display blocks of code. The formatting of this display is done in such a way as to invoke in the mind of the reader the feeling of a terminal, thus making an obvious visual distinction in the text. For instance:</p>
<pre><code class="language-lisp">(defun fib
  ((0) 0)
  ((1) 1)
  ((n)
    (+ (fib (- n 1))
       (fib (- n 2)))))
</code></pre>
<p>Examples such as this one are readily copied and may be pasted without edit into a file or even the LFE REPL itself.</p>
<p>For interactive code, we display the default LFE prompt the reader will see when in the REPL:</p>
<pre><code class="language-lisp">lfe&gt; (integer_to_list 42 2)
;; &quot;101010&quot;
</code></pre>
<p>We also distinguish the output from the entered LFE code using code comments displayed afer the command.</p>
<p>For shell commands, the commands to enter at the prompt are prefixed by a <code>$</code> for the prompt. Input and any relevant output are provided as comment strings:</p>
<pre><code class="language-bash">$ echo &quot;I am excited to learn LFE&quot;
# I am excited to learn LFE
</code></pre>
<h2 id="liffybot"><a class="header" href="#liffybot">LiffyBot</a></h2>
<p><img class="liffy-bot-mascot" src="part1/intro/../../images/LiffyBot-5-x500-bold-color.png"/>This is a severly hoopy frood. With an attitude. He pops up from time to time, generally with good advice. Or simply as a marker for something the authors hope you will pay special note.</p>
<br/>
<h2 id="messages-of-note"><a class="header" href="#messages-of-note">Messages of Note</a></h2>
<p>From time to time you will see call-out boxes, aimed at drawing your attention to something of note. There are four differnt types of these:</p>
<ul>
<li>ones that share useful info (blue)</li>
<li>ones that highlight something of a momentus nature (green)</li>
<li>ones that offer warnings to tred carefully (orange)</li>
<li>ones that beg you not to follow a particular path (red)</li>
</ul>
<p>These messages will take the following forms:</p>
<div class="alert alert-info">
  <h4 class="alert-heading">
    <i class="fa fa-info-circle" aria-hidden="true"></i>
    Information
  </h4>
  <p class="mb-0">
    Here you will see a message of general interest that could have a useful or even positive impact on your experience in programming LFE.
<p>The icon associated with this type of message is the &quot;i&quot; in a circle.</p>
</p>
</div>
<br/>
<div class="alert alert-success">
  <h4 class="alert-heading">
    <img class="liffy-bot-alert" src="part1/intro/../../images/LiffyBot-5-x64-bold-black-solid.png"/>
    Amazing!
  </h4>
  <p class="mb-0">
    Here you will see a message of general celebration for sitations that warrant it, above and beyond the general celebration you will feel writing programs in a distributed Lisp.
<p>The icon assocated with this type of message is that of LiffyBot.</p>
</p>
</div>
<br/>
<div class="alert alert-warning">
  <h4 class="alert-heading">
    <i class="fa fa-exclamation-triangle" aria-hidden="true"></i>
    Warning!
  </h4>
  <p class="mb-0">
    Here you will see a message indicating a known isssue or practice you should avoid if possible.
<p>The icon assocated with this type of message is the &quot;!&quot; in a caution triangle.</p>
</p>
</div>
<br/>
<div class="alert alert-danger">
  <h4 class="alert-heading">
    <i class="fa fa-minus-circle" aria-hidden="true"></i>
    Danger!
  </h4>
  <p class="mb-0">
    Here you will see a message indicating something that could endanger the proper function of an LFE system or threaten the very existence of the universe itself.
<p>The icon assocated with this type of message is &quot;do not enter&quot;.</p>
</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h1>
<h2 id="rebar3-configuration"><a class="header" href="#rebar3-configuration"><code>rebar3</code> Configuration</a></h2>
<p>Having followed the notes and linked instructions in the <a href="part1/intro/prereq.html">Prerequisites</a> section, you are ready to add global support for the LFE <code>rebar3</code> plugin.</p>
<p>First, unless you have configured other <code>rebar3</code> plugins on your system, you will need to create the configuration directory and the configuration file:</p>
<pre><code class="language-bash">$ mkdir ~/.config/rebar3
$ touch ~/.config/rebar3/rebar.config
</code></pre>
<p>Next, open up that file in your favourite editor, and give it these contents:</p>
<pre><code class="language-erlang">{plugins, [
  {rebar3_lfe,
    {git, &quot;https://github.com/lfe-rebar3/rebar3_lfe.git&quot;, {branch, &quot;master&quot;}}}
]}.
</code></pre>
<p>If you already have a <code>rebar.config</code> file with a plugins entry, then simply add a comma after the last plugin listed and paste the <code>{rebar3_lfe, {...}}</code> line from above (with no trailing comma!).</p>
<div class="alert alert-info">
  <h4 class="alert-heading">
    <i class="fa fa-info-circle" aria-hidden="true"></i>
    For Windows users
  </h4>
  <p class="mb-0">Some notes on compatibility:</p>
  <p class="mb-0">
    While LFE, Erlang, and <code>rebar3</code> work on *NIX, BSD, and Windows systems, much of the development the community does occurs predominently on the first two and sometimes Windows support is spotty and less smooth than on the more used platforms (this is more true for <code>rebar3</code> and LFE, and _most_ true for LFE).
<p>In particular, starting a REPL in Windows can take a little more effort (an extra step or two) than it does on, for example, Linux and Mac OS X machines.</p>
</p>
</div>
<h2 id="a-quick-test-with-the-repl"><a class="header" href="#a-quick-test-with-the-repl">A Quick Test with the REPL</a></h2>
<p>With the LFE <code>rebar3</code> plugin successfully configured, you should be able to start up the LFE REPL anywhere on your system with the following:</p>
<pre><code class="language-shell">$ rebar3 lfe repl
</code></pre>
<pre><code class="language-text">Erlang/OTP 23 [erts-11.0] [source] [64-bit] [smp:16:16] [ds:16:16:10] [async-threads:1] [hipe]

   ..-~.~_~---..
  (      \\     )    |   A Lisp-2+ on the Erlang VM
  |`-.._/_\\_.-':    |   Type (help) for usage info.
  |         g |_ \   |
  |        n    | |  |   Docs: http://docs.lfe.io/
  |       a    / /   |   Source: http://github.com/rvirding/lfe
   \     l    |_/    |
    \   r     /      |   LFE v1.3-dev (abort with ^G)
     `-E___.-'

lfe&gt;
</code></pre>
<p>Exit out of the REPL for now by typing <code>&lt;CTRL&gt;&lt;G&gt;</code> and  thn <code>&lt;Q&gt;</code>.</p>
<div class="alert alert-warning">
  <h4 class="alert-heading">
    <i class="fa fa-exclamation-triangle" aria-hidden="true"></i>
    For Windows users
  </h4>
  <p class="mb-0">
    On Windows, this currently puts you into the Erlang shell, not the LFE REPL. To continue to the LFE REPL, you will need to enter <code>lfe_shell:server().</code> and then press <code>&lt;ENTER&gt;</code>.
  </p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">'Hello, World!'</a></h1>
<p>Hello-World style introductory programs are intended to give the potential programmer for that language a sense of what it is like to write a minimalist piece of software with the language in question. In particular, it should show off the minimum capabilitiues of the language, essentially, what you could be in for should you decide upon this path.</p>
<p>In the case of LFE/OTP, this is extremely misleading. But more on that in the OTP version of the Hello-World program.</p>
<p>In this section we will concede to conventional practice and produce a minimal Hello-World that does what many other languages' Hello-World programs do.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-the-repl"><a class="header" href="#from-the-repl">From the REPL</a></h1>
<p>As previously demonstrated, it is possible to start up the LFE 'read-eval-print loop' (REPL) using <code>rebar3</code>:</p>
<pre><code class="language-bash">$ rebar3 lfe repl
</code></pre>
<p>Once you are at the LFE prompt, you may write a simple LFE &quot;program&quot; like the following:</p>
<pre><code class="language-lisp">lfe&gt; (io:format &quot;~p~n&quot; (list &quot;Hello, World!&quot;))
</code></pre>
<p>Or, for the terminally lazy:</p>
<pre><code class="language-lisp">lfe&gt; (io:format &quot;~p~n&quot; '(&quot;Hello, World!&quot;))
</code></pre>
<p>While technically a program, it is not a very interesting one: we didn't create a function of our own, nor did we run it from outside the LFE interactive programming environment.</p>
<p>Let's address one of those points right now. Try this:</p>
<pre><code class="language-lisp">lfe&gt; (defun hello-world ()
lfe&gt;   (io:format &quot;~p~n&quot; '(&quot;Hello, World!&quot;)))
</code></pre>
<p>This is a simple function definition in LFE.</p>
<p>We can run it by calling it:</p>
<pre><code class="language-lisp">lfe&gt; (hello-world)
;; &quot;Hello, World!&quot;
;; ok
</code></pre>
<p>When we execute our <code>hello-world</code> function, it prints our message to <code>standard-output</code> and then lets us know everything really quite fine with a friendly <code>ok</code>. LFE displays <code>ok</code> as output for functions that do not return a value.</p>
<p>Now let's address the other point: running a Hello-World programming from outside LFE.</p>
<p>Hit <code>&lt;CTRL-G&gt;&lt;Q&gt;</code> to exit the REPL and get back to your terminal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-the-command-line"><a class="header" href="#from-the-command-line">From the Command Line</a></h1>
<p>From your system shell prompt, run the following to create a new project that will let us run a Hello-World program from the command line:</p>
<pre><code class="language-bash">$ rebar3 new lfe-main hello-world
$ cd ./hello-world
</code></pre>
<p>Once in the project directory, you can actually just do this:</p>
<pre><code class="language-bash">$ rebar3 lfe run
</code></pre>
<p>You will see code getting downloaded and compiled, and then your script will run, generating the following output:</p>
<pre><code class="language-text">Running script '/usr/local/bin/rebar3' with args [] ...
'hello-world
</code></pre>
<p>When you created a new LFE project of type 'main', a Hello-World function was automatically generated for you, one that's even simpler than what we created in the previous section:</p>
<pre><code class="language-lisp">(defun my-fun ()
  'hello-world)
</code></pre>
<p>The other code that was created when we executed <code>rebar3 new lfe-main hello-world</code> was a script meant to be used by LFE with LFE acting as a shell interpreter:</p>
<pre><code class="language-lisp">#!/usr/bin/env lfescript

(defun main (args)
  (let ((script-name (escript:script_name)))
    (io:format &quot;Running script '~s' with args ~p ...~n&quot; `(,script-name ,args))
    (io:format &quot;~p~n&quot; `(,(hello-world:my-fun)))))
</code></pre>
<p>You may be wondering about the <code>args</code> argument to the <code>main</code> function, and the fact that the printed output for the <code>args</code> when we ran this was <code>[]</code>. Let's try something:</p>
<pre><code class="language-bash">$ rebar3 lfe run -- Fenchurch 42
</code></pre>
<pre><code class="language-text">Running script '/usr/local/bin/rebar3' with args [&lt;&lt;&quot;Fenchurch&quot;&gt;&gt;,&lt;&lt;&quot;42&quot;&gt;&gt;] ...
'hello-world'
</code></pre>
<p>We have to provide the two dashes to let <code>rebar3</code> know that we're done with it, that the subsequent argsuments are not for it, but rather for the program we want it to start for us. Using it causes everything after the <code>--</code> to be passed as arguments to our script.</p>
<p>As for the code itself, it's tiny. But there is a lot going on just with these two files. Have no fear, though: the remainder of this book will explore all of that and more. For now, know that the main function in the executable is calling the <code>hello-world</code> module's <code>my-fun</code> function, which takes no arguments. To put another way, what we really have here is a tiny, trivial library project with the addition of a script that calls a function from that library.</p>
<p>For now just know that an executable file which starts with <code>#!/usr/bin/env lfescript</code> and contains a <code>main</code> function accepting one argument is an LFE script capable of being executed from the command line -- a we have shown!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lfeotp-hello-world"><a class="header" href="#lfeotp-hello-world">LFE/OTP 'Hello, World!'</a></h1>
<p>What have been demonstrated so far are fairly vanilla Hello-World examples; there's nothing particularly interesting about them, which puts them solidly iin the company of the millions of other Hello-World programs. As mentioned before, this approach is particularly vexing in the case of LFE/OTP, since it lures the prospective developer into the preconception that BEAM languages are just like other programming languages. They most decidfedluy are not.</p>
<p>What makes them, and in this particular case LFE, special is OTP. There's really nothing quite like it, certainly not baked into the heart and soul of another programming language. Most useful applications you will write in LFE/OTP will be composed of some sort of long-running service or server, something that manages that server and restarts it in the event of errors, and lastly, a context that contains both, the latter usually referred to as the &quot;application&quot; itself.</p>
<p>As such, a <em>real</em> Hello-World in LFE would be honest and let the prospective developer know what they are in for (and what power will be placed at their fingertips). <em>That</em> is what we will show now, a <em>real</em> LFE Hello-World example.</p>
<p>If you are still in the directory of the previous Hello-World project, let's get out of that:</p>
<pre><code class="language-bash">$ cd ../
</code></pre>
<p>Now we're going to create a new project, one utilising the some very basic OTP patterns:</p>
<pre><code class="language-bash">$ rebar3 new lfe-app hello-otp-world
$ cd ./hello-otp-world
</code></pre>
<p>We won't look at the code for this right now, since there are chapters dedicated to that in the second half of the book. But let's brush the surface with a quick run in the REPL:</p>
<pre><code class="language-bash">$ rebar3 lfe repl
</code></pre>
<p>To start your new hello-world application, use the OTP <code>application</code> module:</p>
<pre><code class="language-lisp">lfe&gt; (application:ensure_all_started 'hello-otp-world)
;; #(ok (hello-otp-world))
</code></pre>
<p>That message lets you know that not only was the <code>hello-otp-word</code> application and server started without issue, any applications upon which it depends were also started. Furthermore, there is a supervisor for our server, and it has started as well. Should our Hello-World server crash for any reason, the supervisor will restart it.</p>
<p>To finish the demonstration, and display the clich√©d if classic message:</p>
<pre><code class="language-lisp">(hello-otp-world:echo &quot;Hello, OTP World!&quot;)
;; &quot;Hello, OTP World!&quot;
</code></pre>
<p>And that, dear reader, is a <em>true</em> LFE/OTP Hello-World program, complete with message-passing and pattern-matching!</p>
<p>Feel free to poke around in the code that was generated for you, but know that eventually all its mysteries will be revealed, and by the end of this book this program's magic will just seem like ordinary code to you, ordinary, dependable, fault-tolerant, highly-availble, massively-concurrent code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="walk-through-an-lfe-guessing-game"><a class="header" href="#walk-through-an-lfe-guessing-game">Walk-through: An LFE Guessing Game</a></h1>
<p>Now that you've seen some LFE in action, let's do something completely insane: write a whole game before we even know the language!</p>
<p>We will follow the same patterns established in the Hello-World examples, so if you are still in one of the Hello-World projects, change directory and then create a new LFE project:</p>
<pre><code class="language-bash">$ cd ../
$ rebar3 new lfe-app guessing-game
$ cd ./guessing-game
</code></pre>
<p>We will create this game by exploring functions in the REPL and then saving the results in a file. Open up your generated project in your favourite code-editing application, and then open up a terminal from your new project directory, and start the REPL:</p>
<pre><code class="language-bash">$ rebar3 lfe repl
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="planning-the-game"><a class="header" href="#planning-the-game">Planning the Game</a></h1>
<p>We've created our new project, but before we write even a single atom of code, let's take a moment to think about the problem and come up with a nice solution. Byt doing this, we increase our chances of making something both useful and elegant. As long as what we write remains legible and meets our needs, the less we write the better. This sort of practice elegance will make the code easier to maintain and reduce the chance for bugs (by the simple merrit of there being less code in which a bug may arise; the more code, the greater opportunities for bugs).</p>
<p>Our first step will be making sure we understand the problem and devising some minimal abstractions. Next, we'll think about what actually need to happen in the game. With that in hand, we will know what state we need to track. Then, we're off to the races: all the code will fall right into place and we'll get to play our game.</p>
<h2 id="key-abstractions"><a class="header" href="#key-abstractions">Key Abstractions</a></h2>
<p>In a guessing game, there are two players: one who has the answer, and one who seeks the answer. Our code and data should clearly model these two players.</p>
<h2 id="actions"><a class="header" href="#actions">Actions</a></h2>
<p>The player with the answer needs to peform the following actions:</p>
<ol>
<li>At the beginning of the game, state the problem and tell the other player to start guessing</li>
<li>Receive the other player's guess</li>
<li>Check the guess against the answer</li>
<li>Report back to the other player on the provided guess</li>
<li>End the game if the guess was correct</li>
</ol>
<p>The guessing player needs to take only one action:</p>
<ol>
<li>guess!</li>
</ol>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>We need to track the state of the game. Based upon the actions we've examined, the overall state is very simple. Through the course of the game, will only need to preserve the answer that will be guessed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-explore"><a class="header" href="#code-explore">Code Explore</a></h1>
<p>Now that we've thought through our problem space clearly and cleanly, let's do some code exploration and start defining some functions we think we'll need.</p>
<p>We've already generated an OTP application using the LFE <code>rebar3</code> plugin, and once we've got our collection of functions that address the needed game features, we can plug those into the application.</p>
<p>We'll make those changes in the code editor you've opened, and we'll explore a small set of possible functions to use for this using the project REPL session you've just started.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-user-input"><a class="header" href="#getting-user-input">Getting User Input</a></h1>
<p>How do we get user input in LFE? Like this!</p>
<pre><code class="language-lisp">lfe&gt; (io:fread &quot;Guess number: &quot; &quot;~d&quot;)
</code></pre>
<p>This will print the prompt <code>Guess number:</code> and then await your input and the press of the <code>&lt;ENTER&gt;</code> key. The input you provide needs to match the format type given in the second argument. In this case, the <code>~d</code> tells us that this needs to be a decimal (base 10) integer.</p>
<pre><code class="language-lisp">fe&gt; (io:fread &quot;Guess number: &quot; &quot;~d&quot;)
;; Guess number: 42
;; #(ok &quot;*&quot;)
</code></pre>
<p>If we try typing something that is not a base 10 integer, we get an error:</p>
<pre><code class="language-lisp">lfe&gt; (io:fread &quot;Guess number: &quot; &quot;~d&quot;)
;; Guess number: forty-two
;; #(error #(fread integer))
</code></pre>
<p>With correct usage, how do we capture the value in a variable? The standard way to do this in LFE is destructuring via pattern matching. The following snippet extracts the value and then prints the extracted value in the REPL:</p>
<pre><code class="language-lisp">lfe&gt; (let ((`#(ok (,value)) (io:fread &quot;Guess number: &quot; &quot;~d&quot;)))
lfe&gt;   (io:format &quot;Got: ~p~n&quot; `(,value)))
;; Guess number: 42
;; Got: 42
;; ok
</code></pre>
<p>We'll talk a lot more about pattern matching in the future, as well as the meaning of the backtick and commas. For now,let's keep pottering in the REPL with these explorations, and make a function for this:</p>
<pre><code class="language-lisp">lfe&gt; (defun guess ()
lfe&gt;   (let ((`#(ok (,value)) (io:fread &quot;Guess number: &quot; &quot;~d&quot;)))
lfe&gt;     (io:format &quot;You guessed: ~p~n&quot; `(,value))))
</code></pre>
<p>And call it:</p>
<pre><code class="language-lisp">lfe&gt; (guess)
;; Guess number: 42
;; You guessed: 42
;; ok
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checking-the-input"><a class="header" href="#checking-the-input">Checking the Input</a></h1>
<p>In LFE there are several ways in which you can perform checks on values:</p>
<ul>
<li>the <code>if</code> form</li>
<li>the <code>cond</code> form</li>
<li>the <code>case</code> form</li>
<li>pattern-matching and/or guards in function heads</li>
</ul>
<p>The last one is commonly used in LFE when passing messages / data between functions. Our initial, generated project code is already doing this, and given the game state data we will be working with, this feels like a good fit what we need to implement.</p>
<p>Normally records are used for application data, but since we just care about the value of two integers (the number selected for the answer and the number guessed by the player), we'll keep things simple in this game:</p>
<pre><code class="language-lisp">(set answer 42)
</code></pre>
<p>Let's create a function with a guard:</p>
<pre><code class="language-lisp">lfe&gt; (defun check
lfe&gt;   ((guess) (when (&lt; guess answer))
lfe&gt;    (io:format &quot;Guess is too low~n&quot;)))
</code></pre>
<p>The extra parenthesis around the function's arguments is due to the use of the pattern-matching form of function definition we're using here. We need this form, since we're going to use a guard. The <code>when</code> after the function args is called a &quot;guard&quot; in LFE. As you might imagine, we could use any number of these.</p>
<pre><code class="language-lisp">lfe&gt; (check 10)
;; Guess is too low
;; ok
</code></pre>
<p>Let's add some more guards for the other checks we want to perform:</p>
<pre><code class="language-lisp">lfe&gt; (defun check
lfe&gt;   ((guess) (when (&lt; guess answer))
lfe&gt;    (io:format &quot;Guess is too low~n&quot;))
lfe&gt;   ((guess) (when (&gt; guess answer))
lfe&gt;    (io:format &quot;Guess is too high~n&quot;))
lfe&gt;   ((guess) (when (== guess answer))
lfe&gt;    (io:format &quot;Correct!~n&quot;)))
</code></pre>
<pre><code class="language-lisp">lfe&gt; (check 10)
;; Guess is too low
;; ok
</code></pre>
<pre><code class="language-lisp">lfe&gt; (check 100)
;; Guess is too high
;; ok
</code></pre>
<pre><code class="language-lisp">lfe&gt; (check 42)
;; Correct!
;; ok
</code></pre>
<p>This should give a very general sense of what is possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-into-an-application"><a class="header" href="#integrating-into-an-application">Integrating into an Application</a></h1>
<p>We're only going to touch one of the files that was generated when you created the <code>guessing-game</code> project: <code>./src/guessing-game.lfe</code>. You can ignore all the others. Once we've made all the changes summarized below, we will walk through this file at a high level, discussing the changes and how those contribute to the completion of the game.</p>
<p>First though, we need to reflect on the planning we just did, remembering the actions and states that we want to support. There's also another thing to consider, since we're writing this as is an always-up OTP app. With some adjustments for state magagement, it could easily be turned into something that literally millions of users could be accessing simultaneouslyi. So: how does a game that is usually implemented as a quick CLI toy get transformed in LFE/OTP such that it can be run as a server?</p>
<p>In short, we'll use OTP's <code>gen_server</code> capability (&quot;behaviour&quot;) and the usual message-passing practices. As such, the server will need to be able to process the following messages:</p>
<ul>
<li><code>#(start-game true)</code> (create a record to track game state)</li>
<li><code>#(stop-game true)</code> (clear the game state)</li>
<li><code>#(guess n)</code>
<ul>
<li>check for guess equal to the answer</li>
<li>greater than the answer, and</li>
<li>less than the answer</li>
</ul>
</li>
</ul>
<p>We could have just used atoms for the first two, and done away with the complexity of using tuples for those, but symmetry is nice :-)</p>
<p>To create the game, we're going to need to perform the following integration tasks:</p>
<ul>
<li>Update the <code>handle_cast</code> function to process the commands and guards we listed above</li>
<li>Create API functions that cast the appropriate messages</li>
<li>Update the <code>export</code> form in the module definition</li>
<li>Set the random seed so that the answers are different every time you start the application</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handle_cast"><a class="header" href="#handle_cast"><code>handle_cast</code></a></h1>
<p>The biggest chunk of code that needs to be changed is the <code>handle_cast</code> function. Since our game doesn't return values, we'll be using <code>handle_cast</code>. (If we needed to have data or results returned to us in the REPL, we would have used <code>handle_call</code> instead. Note that both are standard OTP <code>gen_server</code> callback functions.)</p>
<p>The generated project barely populates this function and the function isn't of the form that supports patten-matching (which we need here) so we will essentially be replacing what was generated. In the file <code>./src/guessing-game.lfe</code>, change this:</p>
<pre><code class="language-lisp">(defun handle_cast (_msg state)
  `#(noreply ,state))
</code></pre>
<p>to this:</p>
<pre><code class="language-lisp">(defun handle_cast
  ((`#(start-game true) _state)
   (io:format &quot;Guess the number I have chosen, between 1 and 10.~n&quot;)
   `#(noreply ,(random:uniform 10)))
  ((`#(stop-game true) _state)
   (io:format &quot;Game over~n&quot;)
   '#(noreply undefined))
  ((`#(guess ,n) answer) (when (== n answer))
   (io:format &quot;Well-guessed!!~n&quot;)
   (stop-game)
   '#(noreply undefined))
  ((`#(guess ,n) answer) (when (&gt; n answer))
   (io:format &quot;Your guess is too high.~n&quot;)
   `#(noreply ,answer))
  ((`#(guess ,n) answer) (when (&lt; n answer))
   (io:format &quot;Your guess is too low.~n&quot;)
   `#(noreply ,answer))
  ((_msg state)
   `#(noreply ,state)))
</code></pre>
<p>That is a single function in LFE, since for every match the arity of the function remains the same. It is, however, a function with six different and separate arguement-body forms: one for each pattern and/or guard.</p>
<p>These patterns are matched:</p>
<ol>
<li>start</li>
<li>stop</li>
<li>guess (three times)</li>
<li>any</li>
</ol>
<p>For the three guess patterns (well, one pattern, really) since there are three different guards we want placed on them:</p>
<ol>
<li>guess is equal</li>
<li>guess is greater</li>
<li>guess is less</li>
</ol>
<p>Note that the pattern for the function argument in these last three didn't change, only the guard is different beptween them.</p>
<p>Finally, there's the original &quot;pass-through&quot; or &quot;match-any&quot; pattern (this is used to prevent an error in the event of an unexpected message type).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-api"><a class="header" href="#game-api">Game API</a></h1>
<p>In order to send a message to a running OTP server, you use special OTP functions for the type of server you are running. Our game is running a <code>gen_server</code> so we'll be using that OTP module to send messages, in particular we'll be calling <code>gen_server:cast</code>. However, creating messages and sending them via the appropriate <code>gen_server</code> function can get tedious quickly, so it is common practice to create API functions that do these things for you.</p>
<p>In our case, we want to go to the section with the heading <code>;;; our server API</code> and add the following:</p>
<pre><code class="language-lisp">(defun start-game ()
  (gen_server:cast (SERVER) '#(start-game true)))

(defun stop-game ()
  (gen_server:cast (SERVER) '#(stop-game true)))

(defun guess (n)
  (gen_server:cast (SERVER) `#(guess ,n)))
</code></pre>
<p>Functions in LFE are private by default, so simply adding these functions doesn't make them publicly accessible. As things now stand these will not be usable outside their module; if we want to use them, e.g., from the REPL, we need to export them.</p>
<p>Go to the top of the <code>guessing-game</code> module and update the &quot;server API&quot; sectopm of the <code>export</code>s, chaning this:</p>
<pre><code class="language-lisp">    ;; server API
    (pid 0)
    (echo 1)))
</code></pre>
<p>to this:</p>
<pre><code class="language-lisp">    ;; server API
    (pid 0)
    (echo 1)
    (start-game 0)
    (stop-game 0)
    (guess 1)))
</code></pre>
<p>The final form of your module definition should look like this:</p>
<pre><code class="language-lisp">(defmodule guessing-game
  (behaviour gen_server)
  (export
    ;; gen_server implementation
    (start_link 0)
    (stop 0)
    ;; callback implementation
    (init 1)
    (handle_call 3)
    (handle_cast 2)
    (handle_info 2)
    (terminate 2)
    (code_change 3)
    ;; server API
    (pid 0)
    (echo 1)
    (start-game 0)
    (stop-game 0)
    (guess 1)))
</code></pre>
<p>Now our game functions are public, and we'll be able to use them from the REPL.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finishing-touches"><a class="header" href="#finishing-touches">Finishing Touches</a></h1>
<p>There is one last thing we can do to make our game more interesting. Right now, the game will work. But every time we start up the REPL and kick off a new game, the same &quot;random&quot; number will be selected for the answer. In order to make things interesting, we need to generate a random seed when we initialize our server. </p>
<p>We want to only do this once, though -- not every time the game starts, and certainly not every time a user guesses! When the LFE server supervisor starts our game server, one functions is called and called only once: <code>init/1</code>. That's where we want to make the change to support a better-than-default random seed.</p>
<p>Let's change that function:</p>
<pre><code class="language-lisp">(defun init (state)
  `#(ok ,state))
</code></pre>
<p>to this:</p>
<pre><code class="language-lisp">(defun init (state)
  (random:seed (erlang:phash2 `(,(node)))
               (erlang:monotonic_time)
               (erlang:unique_integer))
  `#(ok ,state))
</code></pre>
<p>Now we're ready to play!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="playing-the-game"><a class="header" href="#playing-the-game">Playing the Game</a></h1>
<p>If you are still in the REPL, quit out of it so that <code>rebar3</code> can rebuild our changed module. Then start it up again:</p>
<pre><code class="language-bash">$ rebar3 lfe repl
</code></pre>
<p>Once at the LFE propmpt, start up the application:</p>
<pre><code class="language-lisp">lfe&gt; (application:ensure_all_started 'guessing-game)
</code></pre>
<p>With the application and all of its dependencies started, we're ready to start the game and play it through:</p>
<pre><code class="language-lisp">lfe&gt; (guessing-game:start-game)
;; ok
;; Guess the number I have chosen, between 1 and 10.
</code></pre>
<pre><code class="language-lisp">lfe&gt; (guessing-game:guess 10)
;; ok
;; Your guess is too high.
</code></pre>
<pre><code class="language-lisp">lfe&gt; (guessing-game:guess 1)
;; ok
;; Your guess is too low.
</code></pre>
<pre><code class="language-lisp">lfe&gt; (guessing-game:guess 5)
;; ok
;; Your guess is too low.
</code></pre>
<pre><code class="language-lisp">lfe&gt; (guessing-game:guess 7)
;; ok
;; Your guess is too low.
</code></pre>
<pre><code class="language-lisp">lfe&gt; (guessing-game:guess 8)
;; ok
;; Well-guessed!!
;; Game over
</code></pre>
<p style="font-size: 16pt;">
<img class="liffy-bot-mascot" src="part1/intro/guessing-game/../../../images/LiffyBot-5-x500-bold-color.png"/>Success! You've just done something pretty amazing, if still mysterious: you've not only created your first <strong>OTP application</strong> running a <strong>generic server</strong>, you've successully run it through to completion! 
</p>
<p style="font-size: 16pt;">
Until we can dive into all the details of what you've seen in this walkthrough, much of what you've just written will seem strange and maybe even overkill. For now, though, we'll mark a placeholder for those concepts: the next section will briefly review what you've done and indicate which parts of this book will provide the remaining missing pieces.
</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review"><a class="header" href="#review">Review</a></h1>
<p>We've got the whole rest of the book ahead of us to cover much of what you've seen in the sample project we've just created with our guessing game. In the coming pages, you will revisit every aspect of what you've seen so far in lots of detail with correspondingly useful insttruction on these matters.</p>
<p>That being said, it would be unfair to not at least read through the code together and mention the high-level concepts involved. Since we only touched the code in one file, that will be the one that gets the most of our attention for this short review, but let's touch on the others here, too.</p>
<h2 id="project-files"><a class="header" href="#project-files">Project Files</a></h2>
<h3 id="rebarconfig"><a class="header" href="#rebarconfig"><code>rebar.config</code></a></h3>
<p>This is the file you need in every LFE project you will write in order to take advantage of the features (and time-savings!) that <code>rebar3</code> provides. For this project, the two important parts are:</p>
<ol>
<li>the entry for dependencies (only LFE in this case), and</li>
<li>the plugins entry for the LFE rebar3 plugin.</li>
</ol>
<p>Project setup will be covered in Chapter XXX, section XXX.</p>
<h2 id="source-files"><a class="header" href="#source-files">Source Files</a></h2>
<p>The source files for our sample program in this walkthrough are for an OTP application. OTP-based projects will be covered in Chapter XXX, section XXX.</p>
<h3 id="appsrc"><a class="header" href="#appsrc"><code>.app.src</code></a></h3>
<p>This file is mostly used for application metadata. Most of what our app uses in this file is pretty self-explanatory. Every LFE application will have one of these in the project source code. Every LFE library and application needs this file.</p>
<h3 id="guessing-game-applfe"><a class="header" href="#guessing-game-applfe"><code>guessing-game-app.lfe</code></a></h3>
<p>This is the top-level file for our game, an OTP application. It only exports two functions: one to start the app and the other to stop it. The application is responsible for starting up whatever supervisors all your services/servers need. For this sample application, only one supervisor is needed (with a very simple supervision tree).</p>
<h3 id="guessing-game-suplfe"><a class="header" href="#guessing-game-suplfe"><code>guessing-game-sup.lfe</code></a></h3>
<p>This module is a little more invloved and has all the configuration and code necessary to properly set up a supervisor for our server. When something goes wrong with our server, the restart strategy defined by our supervisor will kick in and get things back up and running again. This is one of the key secrets to OTP's wizardry, and we will be covering this in great detail later.</p>
<h3 id="srcguessing-gamelfe"><a class="header" href="#srcguessing-gamelfe"><code>src/guessing-game.lfe</code></a></h3>
<p>This is the last file we'll look at, and is the one we'll cover in the most detail right now. Here's the entire content of what we created for our game:</p>
<pre><code class="language-lisp">(defmodule guessing-game
  (behaviour gen_server)
  (export
   ;; gen_server implementation
   (start_link 0)
   (stop 0)
   ;; callback implementation
   (init 1)
   (handle_call 3)
   (handle_cast 2)
   (handle_info 2)
   (terminate 2)
   (code_change 3)
   ;; server API
   (pid 0)
   (echo 1)
   (start-game 0)
   (stop-game 0)
   (guess 1)))

;;; ----------------
;;; config functions
;;; ----------------

(defun SERVER () (MODULE))
(defun initial-state () '#())
(defun genserver-opts () '())
(defun unknown-command () #(error &quot;Unknown command.&quot;))

;;; -------------------------
;;; gen_server implementation
;;; -------------------------

(defun start_link ()
  (gen_server:start_link `#(local ,(SERVER))
                         (MODULE)
                         (initial-state)
                         (genserver-opts)))

(defun stop ()
  (gen_server:call (SERVER) 'stop))

;;; -----------------------
;;; callback implementation
;;; -----------------------

(defun init (state)
  (random:seed (erlang:phash2 `(,(node)))
               (erlang:monotonic_time)
               (erlang:unique_integer))
  `#(ok ,state))

(defun handle_cast
  ((`#(start-game true) _state)
   (io:format &quot;Guess the number I have chosen, between 1 and 10.~n&quot;)
   `#(noreply ,(random:uniform 10)))
  ((`#(stop-game true) _state)
   (io:format &quot;Game over~n&quot;)
   '#(noreply undefined))
  ((`#(guess ,n) answer) (when (== n answer))
   (io:format &quot;Well-guessed!!~n&quot;)
   (stop-game)
   '#(noreply undefined))
  ((`#(guess ,n) answer) (when (&gt; n answer))
   (io:format &quot;Your guess is too high.~n&quot;)
   `#(noreply ,answer))
  ((`#(guess ,n) answer) (when (&lt; n answer))
   (io:format &quot;Your guess is too low.~n&quot;)
   `#(noreply ,answer))
  ((_msg state)
   `#(noreply ,state)))

(defun handle_call
  (('stop _from state)
   `#(stop shutdown ok state))
  ((`#(echo ,msg) _from state)
   `#(reply ,msg state))
  ((message _from state)
   `#(reply ,(unknown-command) ,state)))

(defun handle_info
  ((`#(EXIT ,_from normal) state)
   `#(noreply ,state))
  ((`#(EXIT ,pid ,reason) state)
   (io:format &quot;Process ~p exited! (Reason: ~p)~n&quot; `(,pid ,reason))
   `#(noreply ,state))
  ((_msg state)
   `#(noreply ,state)))

(defun terminate (_reason _state)
  'ok)

(defun code_change (_old-version state _extra)
  `#(ok ,state))

;;; --------------
;;; our server API
;;; --------------

(defun pid ()
  (erlang:whereis (SERVER)))

(defun echo (msg)
  (gen_server:call (SERVER) `#(echo ,msg)))

(defun start-game ()
  (gen_server:cast (SERVER) '#(start-game true)))

(defun stop-game ()
  (gen_server:cast (SERVER) '#(stop-game true)))

(defun guess (n)
  (gen_server:cast (SERVER) `#(guess ,n)))
</code></pre>
<p>The beginning of the file opens with a declaration of the module: not only its name, but the public functions we want to expose as part of our API. This will be covered in Chapter XXX, section XXX.</p>
<p>Next, we have a few constant functions. Functions are necessary here due to the fact that LFE does not have global variables. This will be covered in Chapter XXX, section XXX.</p>
<p>Then we define the functions that will be used as this module's implementation of a generic OTP server. There is some boilerplate here that will be discussed when we dive into LFE/OTP. This will be covered in Chapter XXX, section XXX.</p>
<p>After that, we define the functions that are used by the OTP machinery that will run our server. Here you see several examples of pattern matching function heads in LFE, a very powerful feature that lends itself nicely to consise and expressive code. This will be covered in Chapter XXX, section XXX.</p>
<p>Lastly, we define our own API. Most of these functions simply send messages to our running server. More on this in Chapter XXX, section XXX.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-lfe-repl"><a class="header" href="#the-lfe-repl">The LFE REPL</a></h1>
<p>We briefly introduced the REPL in the first version of the Hello-World example we wrote, stating that it was an acronym for 'read-eval-print loop' and how to start it with <code>rebar3</code>. As an LFE developer, this is one of the primnary tools -- arguably <em>the</em> most powerful -- at your disposal, so we're going to do a more thorough job of introducing its capabilities in this section.</p>
<div class="alert alert-info">
  <h4 class="alert-heading">
    <i class="fa fa-info-circle" aria-hidden="true"></i>
    Historical Note
  </h4>
  <p class="mb-0">
    The first Lisp interpreter was created sometime in late 1958 by then-grad student Steve Russell after reading John McCarthy's definition of <code>eval</code>. He had the idea that the theoretical description provided there could actually be implemented in machine code.
  </p>
  <p class="mb-0">
    In 1963 L Peter Deutsch, a high school student at the time, combined the <code>read</code>, <code>eval</code>, and <code>print</code> core functions to create the first REPL (or, as he termed it then, the 'READ-EVAL-PRINT cycle'). This was done as part of his successful effort to port Lisp 1.5 from the IBM 7090 to the DEC PDP-1 and is referenced briefly in a <a href="https://www.computerhistory.org/collections/catalog/102650371">written report</a> filed with the Digital Equipment Computer Users Society in 1964.
  </p>
</div>
<p>A basic REPL can be implemented with just four functions; such an implementation could be started with the following:</p>
<pre><code class="language-lisp">(LOOP (PRINT (EVAL (READ))))
</code></pre>
<p>LFE has implemented most these functions for us already (and quite robustly), but we could create our own very limited REPL (single lines with no execution context or environment) within the LFE REPL using the following convenience wrappers:</p>
<pre><code class="language-lisp">(defun read ()
  (case (io:get_line &quot;myrepl&gt; &quot;)
    (&quot;quit\n&quot; &quot;quit&quot;)
    (str (let ((`#(ok ,expr) (lfe_io:read_string str)))
           expr))))

(defun print (result)
  (lfe_io:format &quot;~p~n&quot; `(,result))
  result)

(defun loop
  ((&quot;quit&quot;)
   'good-bye)
  ((code)
   (loop (print (eval (read))))))
</code></pre>
<p>Now we can start our custom REPL inside the LFE REPL:</p>
<pre><code class="language-lisp">lfe&gt; (loop (print (eval (read))))
</code></pre>
<p>This gives us a new prompt:</p>
<pre><code class="language-lisp">myrepl&gt;
</code></pre>
<p>At this prompt we can evaluate basic LFE expressions:</p>
<pre><code class="language-lisp">myrepl&gt; (+ 1 2 3)
;; 6
myrepl&gt; (* 2 (lists:foldl #'+/2 0 '(1 2 3 4 5 6)))
;; 42
myrepl&gt; quit
;; good-bye
lfe&gt;
</code></pre>
<p>Note that writing an evaluator is the hard part, and we've simply re-used the LFE evaluator for this demonstration.</p>
<p>Now that we've explored some of the background of REPLs and Lisp interpreters, let's look more deeply into the LFE REPL and how to best take advantage of its power when using the machine that is LFE and OTP.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-features"><a class="header" href="#core-features">Core Features</a></h1>
<p>In keeping with the overall herritage of LFE, its REPL is both a Lisp REPL as well as an Erlang shell. In fact, when support was added for the LFE REPL to the <code>rebar3_lfe</code> plugin, it utilised <em>all</em> of the plumbing for the Erlang shell support in <code>rebar3</code>.</p>
<p>For the developer, though, this means that the LFE REPL holds a dual set of features, multiplying the set of features available to just the Erlang shell. These features include the following support:</p>
<ul>
<li>Evaluation of Lisp S-expressions</li>
<li>Definition of functions, completely with LFE tail-recursion support</li>
<li>Definition of records and use of record-specific support functions/macros</li>
<li>Creation of LFE macros via standard Lisp-2 syntax</li>
<li>Macro examination and debugging with various expansion macros</li>
<li>The ability to start the LFE REPL in distribution mode, complete with Erlang cookie, and thus to not only access remote LFE and Erlang nodes, but to be accessed as a remote node itself (for nodes that have been granted access</li>
<li>Access to the Erlang JCL and the ability to start separate, LFE shells running concurrently</li>
</ul>
<h2 id="unsupported"><a class="header" href="#unsupported">Unsupported</a></h2>
<p>The following capabilities are not supported in the LFE REPL:</p>
<ul>
<li>Module definitions; these are a file-based feature in LFE, just as with Erlang.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starting-lfe"><a class="header" href="#starting-lfe">Starting LFE</a></h1>
<h2 id="the-lfe-executable"><a class="header" href="#the-lfe-executable">The <code>lfe</code> executable</a></h2>
<p>While this book focuses upon the use of <code>rebar3</code> and its LFE plugin -- due entirely to the amount of time it saves through various features it supports -- LFE may be used quite easily without it.</p>
<p>To use LFE and its REPL without <code>rebar3</code>, you'll need to clone the repo, e.g.:</p>
<pre><code class="language-bash">$ cd ~/lab
$ git clone https://github.com/rvirding/lfe.git
$ cd lfe
</code></pre>
<p>Since you have read the earlier section on dependencies, you already have Erlang, <code>make</code>, and your system build tools installed. As such, all you have to do is run the following to build LFE:</p>
<pre><code class="language-bash">$ make
</code></pre>
<p>This will generate an executable in <code>./bin</code> and you can start the LFE REPL by calling it:</p>
<pre><code class="language-bash">$ ./bin/lfe
</code></pre>
<pre><code class="language-text">Erlang/OTP 23 [erts-11.0.2] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [hipe] [dtrace]

   ..-~.~_~---..
  (      \\     )    |   A Lisp-2+ on the Erlang VM
  |`-.._/_\\_.-':    |   Type (help) for usage info.
  |         g |_ \   |
  |        n    | |  |   Docs: http://docs.lfe.io/
  |       a    / /   |   Source: http://github.com/rvirding/lfe
   \     l    |_/    |
    \   r     /      |   LFE v1.3-dev (abort with ^G)
     `-E___.-'

lfe&gt;
</code></pre>
<p>If you opt to install LFE system-wide with <code>make install</code>, then you can start the REPL from anywhere by simply executing <code>lfe</code>.</p>
<h2 id="via-rebar3-lfe-repl"><a class="header" href="#via-rebar3-lfe-repl">Via <code>rebar3 lfe repl</code></a></h2>
<p>As demonstrated earlier on several occasions, you can start the LFE REPL with the <code>rebar3</code> LFE plugin (and this is what we'll do in the rest of this manual):</p>
<pre><code class="language-bash">$ rebar3 lfe repl
</code></pre>
<p>Since you have updated your global rebar3 settings (in the &quot;Prerequisites&quot; section, after following the instructions on the <code>rebar3</code> site), you may also start the LFE REPL from anywhere on your machine using the <code>rebar3</code> command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="readline-support"><a class="header" href="#readline-support"><code>readline</code> Support</a></h1>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<h2 id="tab-completion"><a class="header" href="#tab-completion">Tab-Completion</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="help"><a class="header" href="#help"><code>(help)</code></a></h1>
<p>As you gain familiarity with the LFE REPL, one of the most useful and convenient references will be the summary of functions, commands, and variablese that come with the LFE REPL.</p>
<p>To see these, simple call the <code>help</code> or <code>h</code> function:</p>
<pre><code class="language-lisp">lfe&gt; (help)
</code></pre>
<p>That will result in the following being displyed to your terminal:</p>
<pre><code class="language-lisp">LFE shell built-in functions

(c file)       -- compile and load code in &lt;file&gt;
(cd dir)       -- change working directory to &lt;dir&gt;
(clear)        -- clear the REPL output
(doc mod)      -- documentation of a module
(doc mod:mac)  -- documentation of a macro
(doc m:f/a)    -- documentation of a function
(ec file)      -- compile and load code in erlang &lt;file&gt;
(ep expr)      -- print a term in erlang form
(epp expr)     -- pretty print a term in erlang form
(exit)         -- quit - an alias for (q)
(flush)        -- flush any messages sent to the shell
(h)            -- an alias for (help)
(help)         -- help info
(i)            -- information about the system
(i pids)       -- information about a list of pids
(l module)     -- load or reload &lt;module&gt;
(ls)           -- list files in the current directory
(ls dir)       -- list files in directory &lt;dir&gt;
(m)            -- which modules are loaded
(m mod)        -- information about module &lt;mod&gt;
(p expr)       -- print a term
(pp expr)      -- pretty print a term
(pid x y z)    -- convert &lt;x&gt;, &lt;y&gt; and &lt;z&gt; to a pid
(pwd)          -- print working directory
(q)            -- quit - shorthand for init:stop/0
(regs)         -- information about registered processes

LFE shell built-in commands

(reset-environment)             -- reset the environment to its initial state
(run file)                      -- execute all the shell commands in a &lt;file&gt;
(set pattern expr)
(set pattern (when guard) expr) -- evaluate &lt;expr&gt; and match the result with
                                   pattern binding
(slurp file)                    -- slurp in a LFE source &lt;file&gt; and makes
                                   everything available in the shell
(unslurp)                       -- revert back to the state before the last
                                   slurp

LFE shell built-in variables

+/++/+++      -- the tree previous expressions
*/**/***      -- the values of the previous expressions
-             -- the current expression output
$ENV          -- the current LFE environment

ok
</code></pre>
<p>Most of those are documented in stdlib reference for their <a href="http://erlang.org/doc/man/c.html">Erlang counterparts</a>, so be sure to reference that information for details on many of the above.</p>
<p>Those not covered in that Erlang reference manual, or those that are different in their LFE versionsm, include:</p>
<ul>
<li>Built-in Functions
<ul>
<li>Compilation functions</li>
<li>LFE code documentation</li>
<li>Printing and pretty-printing</li>
</ul>
</li>
<li>Built-in commands</li>
<li>Built-in variables</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repl-functions"><a class="header" href="#repl-functions">REPL Functions</a></h1>
<p>Most of the LFE REPL functions are documented in stdlib reference for their <a href="http://erlang.org/doc/man/c.html">Erlang counterparts</a>. This section documents where the LFE REPL help diverges from the Erlang Shell help.</p>
<h2 id="compilation"><a class="header" href="#compilation">Compilation</a></h2>
<p>If you view the Erlang reference manual documentation for compiling files in the shell, you will see differences from what is show in the LFE help text. In particular, <code>(c)</code> is for compiling LFE modules and <code>(ec)</code> needs to be used for compiling Erlang source files.</p>
<p>In both cases, the resulting <code>.beam</code> files are compiled to the current working directory and not to an <code>ebin</code> directory. These <code>.beam</code> files will be found by LFE, since the current working directory is included in the path, but you'll likely want to perform some cleanup afterward.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>You may access the documentation for LFE modules, macros, and functions in the REPL via the <code>doc</code> function. For instance, the Common Lisp compatibility module's documentation:</p>
<pre><code class="language-lisp">lfe&gt; (doc cl)
;; ____________________________________________________________
;; cl
;;
;; LFE Common Lisp interface library.
;;
;; ok
</code></pre>
<p>That module's <code>cond</code> macro documentation:</p>
<pre><code class="language-lisp">lfe&gt; (doc cl:cond)
;; ____________________________________________________________
;; cond
;; args
;; CL compatible cond macro.
;;
;; ok
</code></pre>
<p>That module's <code>pairlis/2</code> function documentation:</p>
<pre><code class="language-lisp">lfe&gt; (doc cl:pairlis/2)
;; ____________________________________________________________
;; pairlis/2
;; keys values
;; Make an alist from pairs of keys values.
;;
;; ok
</code></pre>
<p>Documentation for Erlang modules and fucntions is available via the <a href="part1/repl/c.html">Command Interface</a></p>
<h2 id="printing-data"><a class="header" href="#printing-data">Printing Data</a></h2>
<h3 id="lfe-formatting"><a class="header" href="#lfe-formatting">LFE Formatting</a></h3>
<p>LFE provides some nice convenience functions for displaying data structions in the REPL. Let's say we had a data structure defined thusly:</p>
<pre><code class="language-lisp">lfe&gt; (set data `(#(foo bar baz) #(quux quuz) #(corge grault garply)
lfe&gt; #(plugh xyzzy) #(flurb nirf) #(zobod zirfid)))
</code></pre>
<p>We can print our data with the following:</p>
<pre><code class="language-lisp">lfe&gt; (p data)
;; (#(foo bar baz) #(quux quuz) #(corge grault garply) #(plugh xyzzy) #(flurb nirf) #(zobod zirfid))
;; ok
</code></pre>
<p>Or we can pretty-print it:</p>
<pre><code class="language-lisp">lfe&gt; (pp data)
;;(#(foo bar baz)
;; #(quux quuz)
;; #(corge grault garply)
;; #(plugh xyzzy)
;; #(flurb nirf)
;; #(zobod zirfid))
;; ok
</code></pre>
<h3 id="erlang-formatting"><a class="header" href="#erlang-formatting">Erlang Formatting</a></h3>
<p>The same may be done for displaying data in the Erlang format:</p>
<pre><code class="language-lisp">lfe&gt; (ep data)
;; [{foo,bar,baz},{quux,quuz},{corge,grault,garply},{plugh,xyzzy},{flurb,nirf},{zobod,zirfid}]
;; ok
</code></pre>
<pre><code class="language-lisp">lfe&gt; (epp data)
;; [{foo,bar,baz},
;;  {quux,quuz},
;;  {corge,grault,garply},
;;  {plugh,xyzzy},
;;  {flurb,nirf},
;;  {zobod,zirfid}]
;; ok
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repl-commands"><a class="header" href="#repl-commands">REPL Commands</a></h1>
<p>The LFE REPL provides several useful commands users:</p>
<pre><code class="language-lisp">(reset-environment)             -- reset the environment to its initial state
(run file)                      -- execute all the shell commands in a &lt;file&gt;
(set pattern expr)
(set pattern (when guard) expr) -- evaluate &lt;expr&gt; and match the result with
                                   pattern binding
(slurp file)                    -- slurp in a LFE source &lt;file&gt; and makes
                                   everything available in the shell
(unslurp)                       -- revert back to the state before the last
                                   slurp
</code></pre>
<p>These are fairly self-explanatory, with the possible exception of clarifying how <code>run</code> and <code>slurp</code> differ:</p>
<ul>
<li>Calling <code>(run &quot;some/file.lfe&quot;)</code> will cause the LFE REPL to read the contents of that file and then execute every line in that file as if they had been typed at the terminal. This is a convenient way of duplicating REPL state between sessions. (If you haven't kept track of your entries, you can always open up your <a href="part1/repl/readline.html">BEAM history file</a> and create an <code>.lfe</code> file with all the required commands!)</li>
<li>Calling <code>(slurp &quot;some/other/file.lfe&quot;)</code> will place all functions, records, and macros defined in that file into the LFE environment, allowing you to call them without a <code>module:</code> prefix. Note that the code is not executed, but is instead placed into the current environment, ready for use.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="special-variables"><a class="header" href="#special-variables">Special Variables</a></h1>
<pre><code class="language-lisp">LFE shell built-in variables

+/++/+++      -- the tree previous expressions
*/**/***      -- the values of the previous expressions
-             -- the current expression output
$ENV          -- the current LFE environment
</code></pre>
<p>Most of these variables are taken directly from Common Lisp and have the same exact meaning. From the Common Lisp HyperSpec for <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v_pl_plp.htm"><code>+,++,+++</code></a>:</p>
<blockquote>
<p>The variables +, ++, and +++ are maintained by the Lisp read-eval-print loop to save forms that were recently evaluated.</p>
<p>The value of + is the last form that was evaluated, the value of ++ is the previous value of +, and the value of +++ is the previous value of ++.</p>
</blockquote>
<p>And for <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v__stst_.htm"><code>*,**,***</code></a>:</p>
<blockquote>
<p>The variables *, **, and *** are maintained by the Lisp read-eval-print loop to save the values of results that are printed each time through the loop.</p>
<p>The value of * is the most recent primary value that was printed, the value of ** is the previous value of *, and the value of *** is the previous value of **.</p>
</blockquote>
<p>Lastly, for <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v__.htm"><code>-</code></a>:</p>
<blockquote>
<p>The value of - is the form that is currently being evaluated by the Lisp read-eval-print loop.</p>
</blockquote>
<p>The <code>$ENV</code> variable in the LFE REPL is a critical tool for debugging particularly tricky issues in the REPL (especially useful when creating complex macros).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-interface"><a class="header" href="#command-interface">Command Interface</a></h1>
<p>While many of the functions listed in the LFE <code>(help)</code> have their documentation in the <a href="http://erlang.org/doc/man/c.html">Erlang Command Interface module</a> (CIM), not everything in the CIM has been provided in the LFE REPL, some of which can be useful at times.</p>
<p>Here are some of the more useful functions you may with to be aware of from that module:</p>
<ul>
<li><code>(c:bt pid)</code> - Stack backtrace for a process. Equivalent to <code>(erlang:process_display pid 'backtrace)</code>.</li>
<li><code>(c:h mod)</code> - Print the documentation for <code>mod</code></li>
<li><code>(c:h mod fun)</code> - Print the documentation for all <code>mod:fun</code></li>
<li><code>(c:h mod fun arity)</code> - Print the documentation for <code>mod:fun/arity</code></li>
<li><code>(c:lm)</code> - Reloads all currently loaded modules that have changed on disk (see <code>(c:mm)</code>). Returns the list of results from calling <code>(l mod)</code> for each such loaded module.</li>
<li><code>(c:memory)</code> - Memory allocation information. Equivalent to <code>(erlang:memory)</code>.</li>
<li><code>(c:mm)</code> -</li>
<li><code>(c:ni)</code> - Display system information, listing information about all nodes on the network</li>
<li><code>(c:nl mod)</code> - Loads Module on all nodes</li>
<li><code>(c:nregs)</code> - Displays information about all registered processes for all nodes in the network.</li>
<li><code>(c:uptime)</code> - Prints the node uptime (as specified by <code>(erlang:statistics 'wall_clock)</code>) in human-readable form.</li>
<li><code>(c:xm mod)</code> - Finds undefined functions, unused functions, and calls to deprecated functions in a module by calling xref:m/1.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="job-control"><a class="header" href="#job-control">Job Control</a></h1>
<p>When in the LFE REPL, a special mode is accessible upon typing <code>&lt;CTRL-G&gt;</code>:</p>
<pre><code>lfe&gt;
User switch command
 --&gt;
</code></pre>
<p>At the JCL <code>--&gt;</code> prompt, you may get help text by typing <code>?</code>:</p>
<pre><code class="language-text"> --&gt; ?
  c [nn]            - connect to job
  i [nn]            - interrupt job
  k [nn]            - kill job
  j                 - list all jobs
  s [shell]         - start local shell
  r [node [shell]]  - start remote shell
  q                 - quit erlang
  ? | h             - this message
 --&gt;
</code></pre>
<h2 id="running-multiple-shells"><a class="header" href="#running-multiple-shells">Running Multiple Shells</a></h2>
<p>[ also: custom prompts ]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="files"><a class="header" href="#files">Files</a></h1>
<h2 id="repl-only"><a class="header" href="#repl-only">REPL-Only</a></h2>
<h3 id="slurp"><a class="header" href="#slurp"><code>slurp</code></a></h3>
<h3 id="unslurp"><a class="header" href="#unslurp"><code>unslurp</code></a></h3>
<h3 id="compiling-lfe-files"><a class="header" href="#compiling-lfe-files">Compiling LFE Files</a></h3>
<h3 id="compiling-erlang-files"><a class="header" href="#compiling-erlang-files">Compiling Erlang Files</a></h3>
<h2 id="repl--module"><a class="header" href="#repl--module">REPL &amp; Module</a></h2>
<h2 id="include-lib"><a class="header" href="#include-lib"><code>include-lib</code></a></h2>
<h2 id="include-file"><a class="header" href="#include-file"><code>include-file</code></a></h2>
<h2 id="module-loading"><a class="header" href="#module-loading">Module Loading</a></h2>
<p><code>l</code> and <code>code:ensure_loaded</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>In LFE, variables are implemented with <a href="part2/vars/../data-types/atoms.html">atoms</a>. Atoms
are used in the language for such things as naming functions and macros, use as
keywords and in data structures. As you'll find out when reading about atoms,
they are evaluated as simply themselves. However, when they are used as variable
names, they evaulate to the value of which they were assigned.</p>
<p>There are two contexts for setting variables:</p>
<ul>
<li>in the <a href="part2/vars/../../part1/repl">LFE REPL</a></li>
<li>in <a href="part2/vars/../../part3/modules">LFE modules</a></li>
</ul>
<p>This distinction is important, not only because the contexts use different
forms, but because like Erlang, LFE does not support global variables.</p>
<p>This chpater will also introduce the reader to pattern-matching in LFE, as it
applies to variable assignment; a fuller discussion is presented in a
<a href="part2/vars/../patterns">dedicated chapter</a> as well in the chapters that cover forms
which support pattern-matching (i.e., compound data types, functions, etc.).</p>
<p>Lastly we'll talk more about some of the LFE nuances around global variables.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bindings"><a class="header" href="#bindings">Bindings</a></h1>
<h2 id="in-the-repl"><a class="header" href="#in-the-repl">In the REPL</a></h2>
<p>To set a variable in the LFE REPL, use the <code>set</code> macro:</p>
<pre><code class="language-lisp">lfe&gt; (set answer 42)
42
</code></pre>
<p>In the language itself, LFE doesn't support global variables -- a valuable
feature inherited from Erlang. However, in order for a REPL experience to be
useful, an environment must be maintained in which the user may write
expressions and then refer to them later. This environment is essentially a
mechanism for global state in the context of a single user running a single
Erlang VM. If we set a variable called <code>answer</code>, that variable will be available
to us as long as the REPL process continues or until we reset the environment.</p>
<p>Setting another value with the same variable name is allowed: it merely replaces
the assignment in the current REPL environment:</p>
<pre><code class="language-lisp">lfe&gt; (set answer &quot;forty-two&quot;)
&quot;forty-two&quot;
</code></pre>
<p>With a variable assigned with <code>set</code> it may be used at any time in the REPL
environment where it was defined:</p>
<pre><code class="language-lisp">lfe&gt; (++ &quot;The answer is &quot; answer)
&quot;The answer is forty-two&quot;
</code></pre>
<p>Attempting to use a variable that has not been defined results in an error:</p>
<pre><code class="language-lisp">lfe&gt; (++ &quot;The question was &quot; question)
** exception error: symbol question is unbound
  in lfe_eval:eval_error/1 (src/lfe_eval.erl, line 1292)
  in lists:map/2 (lists.erl, line 1243)
  in lists:map/2 (lists.erl, line 1243)
</code></pre>
<p>If you don't have any need to update the environment with data that you only
need for a specific calculation, you may use the <code>let</code> form:</p>
<pre><code class="language-lisp">lfe&gt; (let ((short-lived-value (* 2 (+ 1 2 3 4 5 6))))
lfe&gt;   (io:format &quot;The answer is ~p~n&quot; `(,short-lived-value)))
The answer is 42
ok
</code></pre>
<p>Let's make sure that variable wasn't saved to our environment:</p>
<pre><code class="language-lisp">lfe&gt; short-lived-value
** exception error: symbol short-lived-value is unbound
</code></pre>
<p>The lexical scope for the <code>short-lived-value</code> is within the <code>let</code> only and is
not available outside of that scope.</p>
<h2 id="in-functions-and-macros"><a class="header" href="#in-functions-and-macros">In Functions and Macros</a></h2>
<p>Within functions, variables are lexically scoped and bound with <code>let</code> and
<code>let*</code>. One may also define lexically scoped functions <em>inside</em> other fucntions,
and this is done with <code>flet</code> and <code>fletrec</code> (the latter required for defining
recursive functions inside another function). These will be covered in detail
<a href="part2/vars/../../part3/funs/">later in the book</a>.</p>
<p>We've seen <code>let</code> used above in the REPL; the same applies inside functions:</p>
<pre><code class="language-lisp">(defun display-answer ()
  (let ((answer (* 2 (+ 1 2 3 4 5 6))))
    (io:format &quot;The answer is ~p~n&quot; `(,answer))))
</code></pre>
<p>This is a straight-forward case of assignment; but what if we needed to assign
a varaible that depended upon <em>another</em> variable. Using <code>let</code>, you'd have to do
this:</p>
<pre><code class="language-lisp">(defun display-answer ()
  (let ((data '(1 2 3 4 5 6)))
    (let ((answer (* 2 (lists:sum data))))
      (io:format &quot;The answer is ~p~n&quot; `(,answer)))))
</code></pre>
<p>However, as with other Lisps, LFE provides a convenience macro for this: <code>let*</code>.
Here's how it's used:</p>
<pre><code class="language-lisp">(defun display-answer ()
  (let* ((data '(1 2 3 4 5 6))
         (answer (* 2 (lists:sum data))))
    (io:format &quot;The answer is ~p~n&quot; `(,answer))))
</code></pre>
<p>Lexical scoping helps one isolate unrelated data or calculations, even in the
same function: multiple <code>let</code> or <code>let*</code> blocks may be declared in a function
and none of the bound variables in one block will be available to another block.
Attempting to do so will result in an error.</p>
<h2 id="in-modules"><a class="header" href="#in-modules">In Modules</a></h2>
<p>In LFE, one cannot bind variables at the module-level, only functions and
macros. This is part of the &quot;no global variables&quot; philosophy (and practice!) of
Erlang and LFE. Module-level bindings are done with <code>defun</code> for functions and
<code>defmacro</code> for macros. The creation of <a href="part2/vars/../../part3/modules">modules</a>,
<a href="part2/vars/../../part3/funs">functions</a>, and <a href="part2/vars/../../part4/macros">macros</a> will all be
covered in detail later in the book.</p>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>One shadows a variable in one scope when, at a higher scope, that variable was
also defined. Here's an annotated example:</p>
<pre><code class="language-lisp">(defun shadow-demo ()
  (let ((a 5))
    (io:format &quot;~p~n&quot; `(,a))    ; prints 5
    (let ((a 'foo))             ; 'a' here shadows 'a' in the previous scope
      (io:format &quot;~p~n&quot; `(,a))) ; prints foo
    (io:format &quot;~p~n&quot; `(,a)))   ; prints 5; the shadow binding is out of scope
  (let ((a 42))
    (io:format &quot;~p~n&quot; `(,a))))  ; prints 42 - new scope, no shadowing
</code></pre>
<p>Shadowing also may occur at the module-level with the definition of functions,
and the shadowing could be of functions at one of several levels. Here's a
run-down on function shadowing in modules, from the highest or &quot;outermost&quot; to
the lowest or &quot;innermost&quot;:</p>
<ul>
<li>Predefined Erlang built-in functions (BIFs) may be shadowed by any of the
following</li>
<li>Predefined LFE BIFs may be shadowed by any of the following</li>
<li>Module imports may shadow any of the above via aliasing</li>
<li>Functions defined in a module may shadow any of the above</li>
<li>Functions defined inside a function (e.g., via <code>flet</code> or <code>fletrec</code>) may shadow
any of the above</li>
</ul>
<p>Note that to shadow functions in LFE, functions must match both in name as well
as arity (number of arguments).</p>
<p>The <code>hd</code> Erlang BIF returns the &quot;head&quot; of a list (the first item). Here's an
example of shadowing it in the REPL. Here's the BIF at work:</p>
<pre><code class="language-lisp">lfe&gt; (hd '(a b c d e))
a
</code></pre>
<p>Next, paste this into the REPL:</p>
<pre><code class="language-lisp">(defun hd (_)
  ;; part of the pun here is that the same function in Lisp is called 'car'
  &quot;My other car is The Heart of Gold.&quot;)
</code></pre>
<p>The <code>hd</code> function takes one argument (a list), so our function also needs to
take one. However, since we don't do anything with that, we use the &quot;don't care&quot;
variable <code>_</code>.</p>
<p>Now let's call <code>hd</code> again:</p>
<pre><code class="language-lisp">lfe&gt; (hd '(a b c d e))
&quot;My other car is The Heart of Gold.&quot;
</code></pre>
<p>Shadowed!</p>
<p>Note that, like many other Lisps, LFE has the <code>car</code> function, but since this is
a core form, it can't be shadowed (see the next section).</p>
<h2 id="the-unshadowable"><a class="header" href="#the-unshadowable">The Unshadowable</a></h2>
<p>Shadowing does not apply to the supported LFE
<a href="https://github.com/rvirding/lfe/blob/develop/doc/src/lfe_guide.7.md#core-forms">core forms</a>.
It may appear that
your code is shadowing those forms, but the compiler will <em>always</em> use
the core meaning and never an alternative. It does this silently, without
warning -- so take care and do not be surprised!</p>
<div class="alert alert-info">
  <h4 class="alert-heading">
    <i class="fa fa-info-circle" aria-hidden="true"></i>
    Information
  </h4>
  <p class="mb-0">
    Core LFE forms are never be shadowed.
  </p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching-preview"><a class="header" href="#pattern-matching-preview">Pattern-matching Preview</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-variables-revisted"><a class="header" href="#global-variables-revisted">Global Variables Revisted</a></h1>
<h2 id="the-process-dictionary"><a class="header" href="#the-process-dictionary">The Process Dictionary</a></h2>
<h2 id="ets-tables"><a class="header" href="#ets-tables">ETS Tables</a></h2>
<h2 id="state-and-otp-servers"><a class="header" href="#state-and-otp-servers">State and OTP Servers</a></h2>
<h2 id="external-databases"><a class="header" href="#external-databases">External Databases</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>This chapter covers the basic types of data available to LFE, upon which
primatives rest all LFE libraries and applications.</p>
<ul>
<li>Integers</li>
<li>Floats</li>
<li>Atoms</li>
<li>Booleans</li>
<li>Characters</li>
</ul>
<p>Each of these types has an LFE test function of the form <code>TYPENAMEp</code> (which
wrap the respective Erlang <code>is_TYPENAME</code> function). These are used to perform
type checks (especially common in guard expressions). These predicate functions
will be covered in their respective type sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integers"><a class="header" href="#integers">Integers</a></h1>
<p>Integers in LFE may be either positive or negative and are by default base 10. Like Erlang, LFE does not have a maximum size of integer (in contrast to languages like C). This is accomplished via automatic conversion to larger (or smaller) internal representations (including the use of bignums).</p>
<pre><code class="language-lisp">lfe&gt; 42
42
lfe&gt; -42
-42
lfe&gt; 1764
1764
lfe&gt; 150130937545296561928688012959677941476701514734130607701636390322176
150130937545296561928688012959677941476701514734130607701636390322176
</code></pre>
<h2 id="bases"><a class="header" href="#bases">Bases</a></h2>
<p>Several bases are supported via special syntax:</p>
<pre><code class="language-lisp">lfe&gt; #b101010 ; binary
42
lfe&gt; #o52 ; octal
42
lfe&gt; #d42 ; decimal (explicit base 10)
42)
lfe&gt; #x2a ; hexadecimal
42
</code></pre>
<p>Generic bases are supported, too:</p>
<pre><code class="language-lisp">lfe&gt; #36r16
42
</code></pre>
<p>The number after the hash <code>#</code> is the base and may be any positive integer from 2 through 36. The number after the radix <code>r</code> is the actual value and must only bve comprised of integers allowed for the given base.</p>
<p>Converting between bases in LFE is most easily done via the <code>integer_to_list</code> Erlang function. For example:</p>
<pre><code class="language-lisp">lfe&gt; (integer_to_list 1000 2)
&quot;1111101000&quot;
lfe&gt; (integer_to_list 1000 8)
&quot;1750&quot;
lfe&gt; (integer_to_list 1000 10)
&quot;1000&quot;
lfe&gt; (integer_to_list 1000 16)
&quot;3E8&quot;
lfe&gt; (integer_to_list 1000 36)
&quot;RS&quot;
</code></pre>
<p>If, for whatever reason, you want your base 10 integrer as a list (Erlang/LFE string), you can do that with this:</p>
<pre><code class="language-lisp">lfe&gt; (integer_to_list 1000)
&quot;1000&quot;
</code></pre>
<p>Conversion to the binary type is also supported:</p>
<pre><code class="language-lisp">lfe&gt; (integer_to_binary 1000)
#&quot;1000&quot;
lfe&gt; (integer_to_binary 1000 2)
#&quot;1111101000&quot;
lfe&gt; (integer_to_binary 1000 8)
#&quot;1750&quot;
</code></pre>
<p>The results above show LFE's literal representations of binary data; this will be covered in the chapter on &quot;Bytes and Binaries&quot;.</p>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<p>Integers may be operated upon with the following:</p>
<pre><code class="language-lisp">lfe&gt; (+ 1)
1
lfe&gt; (+ 1 2)
3
lfe&gt; (+ 1 2 3)
6
lfe&gt; (- 1 2 3)
-4
lfe&gt; (* 1 2 3)
6
lfe&gt; (/ 1 2 3)
0.16666666666666666
</code></pre>
<p>Note that the division operator returns a float; floats will be covered in the next section.</p>
<p>Integer division is supported with a 2-arity function:</p>
<pre><code class="language-lisp">lfe&gt; (div 1 2)
0
lfe&gt; (div 10 2)
5
</code></pre>
<p>LFE also supports the remainder operation:</p>
<pre><code class="language-lisp">lfe&gt; (rem 10 3)
1
</code></pre>
<p>As with any functional programming language, these operations may be composed (to any depth):</p>
<pre><code class="language-lisp">lfe&gt; (div (* 12 (+ 1 2 3 4 5 6)) 6)
42
</code></pre>
<h2 id="mathematical-functions"><a class="header" href="#mathematical-functions">Mathematical Functions</a></h2>
<p>The auto-loaded <code>erlang</code> module has several mathematical functions and is
accessible in LFE without having to type the <code>erlang:</code> module prefix in the
function calls. These include the following:</p>
<pre><code class="language-lisp">lfe&gt; (abs -42)
42
lfe&gt; (min 1 2)
1
lfe&gt; (max 1 2)
2
</code></pre>
<p>Additional maths functions are provided via the <code>math</code> module. Since this module
is not auto-loaded, in order to auto-complete it in the REPL you will need to
load it:</p>
<pre><code class="language-lisp">lfe&gt; (code:ensure_loaded 'math)
#(module math)
</code></pre>
<p>Now you can hit <code>&lt;TAB&gt;</code> after typing the following:</p>
<pre><code class="language-lisp">lfe&gt; (math:
</code></pre>
<p>Which gives:</p>
<pre><code>acos/1         acosh/1        asin/1         asinh/1        atan/1
atan2/2        atanh/1        ceil/1         cos/1          cosh/1
erf/1          erfc/1         exp/1          floor/1        fmod/2
log/1          log10/1        log2/1         module_info/0  module_info/1
pi/0           pow/2          sin/1          sinh/1         sqrt/1
tan/1          tanh/1
</code></pre>
<pre><code class="language-lisp">lfe&gt; (round (math:pow 42 42))
150130937545296561928688012959677941476701514734130607701636390322176
</code></pre>
<p>The documentation for these functions is limited (<a href="http://erlang.org/doc/man/math.html">available here</a>) due in part to the fact that these are C library wrappers. Those that aren't documented should be self-explanatory for anyone who has used simular mathematical functions in other programming language libraries.</p>
<h2 id="predicates"><a class="header" href="#predicates">Predicates</a></h2>
<p>To test if a value is an integer, we will first include some code:</p>
<pre><code class="language-lisp">lfe&gt; (include-lib &quot;lfe/include/cl.lfe&quot;)
</code></pre>
<p>That adds Common Lisp inspired functions and macros to our REPL session.</p>
<pre><code class="language-lisp">lfe&gt; (integerp 42)
true
lfe&gt; (integerp 42.24)
false
lfe&gt; (integerp &quot;forty-two&quot;)
false
</code></pre>
<p>If you prefer the Clojure-style of predicates:</p>
<pre><code class="language-lisp">lfe&gt; (include-lib &quot;lfe/include/clj.lfe&quot;)
lfe&gt; (integer? 42)
true
lfe&gt; (integer? &quot;forty-two&quot;)
false
</code></pre>
<p>Of course there is always the Erlang predicate, usable without having to do any includes:</p>
<pre><code class="language-lisp">lfe&gt; (is_integer 42)
true
lfe&gt; (is_integer &quot;forty-two&quot;)
false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floats"><a class="header" href="#floats">Floats</a></h1>
<p>Real numbers in LFE are represented using the stadnard floating point numbers.</p>
<pre><code class="language-lisp">lfe&gt; 42.42
42.42
lfe&gt; (/ 10 3)
3.3333333333333335
lfe&gt; (math:pow 42 42)
1.5013093754529656e68
</code></pre>
<p>Note that the ~<code>1.5e68</code> above is the floating point equivalent of scientific
notation, namely <code>1.5 x 10<sup>68</sup></code>. LFE follows the 64-bit
standard for float representation given by <a href="https://en.wikipedia.org/wiki/IEEE_754-1985">IEEE 754-1985</a>.</p>
<h2 id="converting"><a class="header" href="#converting">Converting</a></h2>
<p>An integer may be converted to a float explicitly:</p>
<pre><code class="language-lisp">lfe&gt; (float 42)
42.0
</code></pre>
<p>Or, as with integers, to binaries:</p>
<pre><code class="language-lisp">lfe&gt; (float_to_binary 42.42)
#&quot;4.24200000000000017053e+01&quot;
lfe&gt; (float_to_binary 42.42 '(#(scientific 10)))
#&quot;4.2420000000e+01&quot;
lfe&gt; (float_to_binary 42.42 '(#(scientific 20)))
#&quot;4.24200000000000017053e+01&quot;
lfe&gt; (float_to_binary 42.42 '(#(decimals 10)))
#&quot;42.4200000000&quot;
lfe&gt; (float_to_binary 42.42 '(#(decimals 10) compact))
#&quot;42.42&quot;
</code></pre>
<p>Or to lists (LFE and Erlang strings):</p>
<pre><code class="language-lisp">lfe&gt; (float_to_list 42.42 '(#(scientific 10)))
&quot;4.2420000000e+01&quot;
lfe&gt; (float_to_list 42.42 '(#(scientific 20)))
&quot;4.24200000000000017053e+01&quot;
lfe&gt; (float_to_list 42.42 '(#(decimals 10)))
&quot;42.4200000000&quot;
lfe&gt; (float_to_list 42.42 '(#(decimals 10) compact))
&quot;42.42&quot;
</code></pre>
<h2 id="formatting"><a class="header" href="#formatting">Formatting</a></h2>
<p>If you need to round floating point numbers to a specific precision, you'll want to use the <code>format</code> function from either the <code>io</code>, <code>io_lib</code>, or <code>lfe_io</code> modules. If just want to print a value using Erlang syntax and formatting, the <code>io</code> module is what you want. If you prefer LFE syntax and formatting for your output, you'll want to use the <code>lfe_io</code> module. If you want to use the data or store it in a variable, you'll need the <code>io_lib</code> library.</p>
<p>For default precision:</p>
<pre><code class="language-lisp">lfe&gt; (io_lib:format &quot;~f&quot; `(,(math:pow 42 42)))
&quot;150130937545296561929000000000000000000000000000000000000000000000000.000000&quot;
</code></pre>
<p>Two decimal places:</p>
<pre><code class="language-lisp">lfe&gt; (io_lib:format &quot;~.2f&quot; `(,(math:pow 42 42)))
&quot;150130937545296561929000000000000000000000000000000000000000000000000.00&quot;
</code></pre>
<p>20 decimal places:</p>
<pre><code class="language-lisp">lfe&gt; (io_lib:format &quot;~.20f&quot; `(,(math:pow 42 42)))
&quot;150130937545296561929000000000000000000000000000000000000000000000000.00000000000000000000&quot;
</code></pre>
<h2 id="arithmetic-operators--mathematical-functions"><a class="header" href="#arithmetic-operators--mathematical-functions">Arithmetic Operators &amp; Mathematical Functions</a></h2>
<p>Floats use most of the same operators and functions as integers, so be sure to 
review <a href="part2/data-types/integers.html#arithmetic-operators">these</a> <a href="part2/data-types/integers.html#mathematical-functions">subsections</a> in the <a href="part2/data-types/integers.html">&quot;Integers&quot; section</a>.</p>
<p>Others include:</p>
<pre><code class="language-lisp">lfe&gt; (abs -42)
42
lfe&gt; (ceil 42.1)
43
lfe&gt; (floor 42.1)
42
lfe&gt; (round 42.4)
42
lfe&gt; (round 42.5)
43
lfe&gt; (min 1 2)
1
lfe&gt; (max 1 2)
2
</code></pre>
<h2 id="predicates-1"><a class="header" href="#predicates-1">Predicates</a></h2>
<p>To test if a value is an integer, we will first include some code:</p>
<pre><code class="language-lisp">lfe&gt; (include-lib &quot;lfe/include/cl.lfe&quot;)
</code></pre>
<p>That adds Common Lisp inspired functions and macros to our REPL session.</p>
<pre><code class="language-lisp">lfe&gt; (floatp 42.42)
true
lfe&gt; (floatp 42)
false
lfe&gt; (floatp &quot;forty-two.forty-two&quot;)
false
</code></pre>
<p>If you prefer the Clojure-style of predicates:</p>
<pre><code class="language-lisp">lfe&gt; (include-lib &quot;lfe/include/clj.lfe&quot;)
lfe&gt; (float? 42.42)
true
lfe&gt; (float? &quot;forty-two.forty-two&quot;)
false
</code></pre>
<p>Of course there is always the Erlang predicate, usable without having to do any includes:</p>
<pre><code class="language-lisp">lfe&gt; (is_float 42.42)
true
lfe&gt; (is_float &quot;forty-two.forty-two&quot;)
false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atoms"><a class="header" href="#atoms">Atoms</a></h1>
<p>The cloest analog in LFE to what most Lisp dialects call symbols is the Erlang
atom. Just as with Lisps do with symbols, LFE uses atoms for its variable and
function names. Atoms are literals and constants, which means that their value
is the same as their name and once created, cannot be changed.</p>
<p>Some basic examples of atoms:</p>
<pre><code class="language-lisp">lfe&gt; 'zark
zark
lfe&gt; 'zarking-amazing
zarking-amazing
</code></pre>
<p>Slightly less straight-forward examples which start with non-alphanumeric
characters:</p>
<pre><code class="language-lisp">lfe&gt; ':answer
:answer
lfe&gt; '42answer
42answer
lfe&gt; '42.0e42answer
42.0e42answer
lfe&gt; '42¬∞C
42¬∞C
</code></pre>
<p>Standard LFE atom names may be comprised of all the latin-1 character set except
the following:</p>
<ul>
<li>control character</li>
<li>whitespace</li>
<li>the various brackets</li>
<li>double quotes</li>
<li>semicolon</li>
</ul>
<p>Of these, only <code>|</code>, <code>\</code>, <code>'</code>, <code>,</code>, and <code>#</code> may not be the first character of the
symbol's name (but they <em>are</em> allowed as subsequent letters).</p>
<p>Non-standard atom names may be created using atom quotes:</p>
<pre><code class="language-lisp">lfe&gt; '|symbol name with spaces|
|symbol name with spaces|
lfe&gt; '|'with staring quote!|
|'with staring quote!|
lfe&gt; '|| ; &lt;-- empty atoms are supported too
||
lfe&gt; '|really weird atom: '#[]{}()&lt;&gt;&quot;;\||
|really weird atom: '#[]{}()&lt;&gt;&quot;;\||
</code></pre>
<p>In this case the name can contain any character of in the range from 0 to 255,
and even no character at all.</p>
<p>In the case of atoms, it is important to understand a little something about
their internals. In particular,
Erlang and LFE atoms are global for each instance of a running Erlang virtual
machine. Atoms are maintained by the VM in a table and are not garbage
collected. By default, the Erlang atom table allows for a maximum of 1,048,576
entries.</p>
<div class="alert alert-danger">
  <h4 class="alert-heading">
    <i class="fa fa-minus-circle" aria-hidden="true"></i>
    Danger!
  </h4>
  <p class="mb-0">
     Uncontrolled autoamtic creation of atoms can crash the VM!
  </p>
   <p class="mb-0">
    See the "Caveats" section below for more details.
  </p>
</div>
<h2 id="as-symbols"><a class="header" href="#as-symbols">As Symbols</a></h2>
<p>The following code shows LFE's use of atoms in variable names. First, let's use
a function for a slighly different purpose than designed: calling
<code>list_to_existing_atom</code> on a string will only return a result if an atom
of the same name already exists in the atom table. Otherwise, it will return
an error:</p>
<pre><code class="language-lisp">lfe&gt; (list_to_existing_atom &quot;zaphod&quot;)
** exception error: bad argument
  in (erlang : list_to_existing_atom &quot;zaphod&quot;)
</code></pre>
<p>This confirms that there is no <code>zaphod</code> atom in the atom table.</p>
<p>Now let's create a variable, assigning a value to it, and then use our indirect
means of checkihg the atom table:</p>
<pre><code class="language-lisp">lfe&gt; (set zaphod &quot;frood&quot;)
&quot;frood&quot;
lfe&gt; (list_to_existing_atom &quot;zaphod&quot;)
zaphod
</code></pre>
<p>And here's an example showing LFE's use of atoms in function names using the
same approach as above:</p>
<pre><code class="language-lisp">lfe&gt; (list_to_existing_atom &quot;beez&quot;)
** exception error: bad argument
  in (erlang : list_to_existing_atom &quot;beez&quot;)

lfe&gt; (defun beez (x) x)
beez
lfe&gt; (list_to_existing_atom &quot;beez&quot;)
beez
</code></pre>
<h2 id="converting-1"><a class="header" href="#converting-1">Converting</a></h2>
<p>Atoms may be converted to strings and bitstrings, and vice versa.</p>
<pre><code class="language-lisp">(atom_to_binary 'trisha)
#&quot;trisha&quot;
(atom_to_binary 'mcmillan 'latin1)
#&quot;mcmillan&quot;
lfe&gt; (atom_to_list 'trillian)
&quot;trillian&quot;
</code></pre>
<p>Note that the first one above is only available in Erlang 23.0 and above.</p>
<p>Some more examples for encoding:</p>
<pre><code class="language-lisp">lfe&gt; (atom_to_binary '42¬∞C 'latin1)
#B(52 50 176 67)
lfe&gt; (atom_to_binary '42¬∞C 'utf8)
#&quot;42¬∞C&quot;
</code></pre>
<p>Functions that convert atoms only if they already exist in the atom table:</p>
<pre><code class="language-lisp">lfe&gt; (binary_to_existing_atom #&quot;trisha&quot;)
trisha
lfe&gt; (binary_to_existing_atom #&quot;trisha&quot; 'latin1)
trisha
lfe&gt; (list_to_existing_atom &quot;trisha&quot;)
trisha
</code></pre>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>The only operators you may use on atoms are the comparison operators, e.g.:</p>
<pre><code class="language-lisp">lfe&gt; (&gt; 'a 'b)
false
lfe&gt; (&lt; 'a 'b)
true
lfe&gt; (=:= 'a 'a)
true
</code></pre>
<h2 id="predicates-2"><a class="header" href="#predicates-2">Predicates</a></h2>
<p>To test if a value is an atom, we will first include some code:</p>
<pre><code class="language-lisp">lfe&gt; (include-lib &quot;lfe/include/cl.lfe&quot;)
</code></pre>
<p>That adds Common Lisp inspired functions and macros to our REPL session.</p>
<pre><code class="language-lisp">lfe&gt; (atomp 'arthur)
true
lfe&gt; (atomp 42)
false
lfe&gt; (atomp &quot;forty-two.forty-two&quot;)
false
</code></pre>
<p>If the atom in question has been used in a function name definition:</p>
<p>If you prefer the Clojure-style of predicates:</p>
<pre><code class="language-lisp">lfe&gt; (include-lib &quot;lfe/include/clj.lfe&quot;)
lfe&gt; (atom? 'dent)
true
lfe&gt; (atom? &quot;Ford&quot;)
false
</code></pre>
<p>Of course there is always the Erlang predicate, usable without having to do any includes:</p>
<pre><code class="language-lisp">lfe&gt; (is_atom 'arthur)
true
lfe&gt; (is_atom &quot;forty-two.forty-two&quot;)
false
</code></pre>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<p>As mentioned above (<a href="http://erlang.org/doc/efficiency_guide/commoncaveats.html">and documented</a>),
one needs to take care when creating atoms. By default, the maximum number of
atoms that the Erlang VM will allow is 1,048,576; any more than that, and the
VM will crash.</p>
<p>The first rule of thumb is not to
write any code that generates large numbers of atoms. More explicitly useful,
there are some handy functions for keeping track of the atom table, should you
have the need.</p>
<pre><code class="language-lisp">lfe&gt; (erlang:memory 'atom_used)
244562
lfe&gt; (erlang:system_info 'atom_count)
9570
lfe&gt; (erlang:system_info 'atom_limit)
1048576
</code></pre>
<p>Note that support for easily extracting the current atom data
from <code>system_info</code> -- as demonstrated by the last two function calls above --
were added in Erlang 20; should you be running an older
version of Erlang, you will need to parse the <code>(system_info 'info)</code>
bitstring.</p>
<p>The default atom table size may be overridden during startup by passing a value
with the <code>+t</code> options:</p>
<pre><code class="language-shell">$ lfe +t 200000001
</code></pre>
<pre><code class="language-lisp">lfe&gt; (erlang:system_info 'atom_limit)
200000001
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booleans"><a class="header" href="#booleans">Booleans</a></h1>
<p>Strictly speaking, LFE has no Boolean type, just like Erlang. Instead, the atoms
<code>true</code> and <code>false</code> are treated as Booleans</p>
<pre><code class="language-lisp">lfe&gt; (== 42 &quot;the question&quot;)
false
lfe&gt; (== 42 42)
true
lfe&gt; (&gt; 1 2)
false
lfe&gt; (&lt; 1 2)
true
</code></pre>
<h2 id="operators-1"><a class="header" href="#operators-1">Operators</a></h2>
<p>The standard logical operators are available to LFE Booleans:</p>
<pre><code class="language-lisp">lfe&gt; (not 'true)
false
lfe&gt; (not 'false)
true
lfe&gt; (and 'true 'false)
false
lfe&gt; (or 'true 'false)
true
lfe&gt; (and 'true 'true 'true)
true
lfe&gt; (and 'true 'true 'false)
false
lfe&gt; (or 'false 'false 'false)
false
lfe&gt; (or 'false 'false 'true)
true
lfe&gt; (xor 'true 'true)
false
lfe&gt; (xor 'true 'false)
true
lfe&gt; (xor 'false 'false)
false
lfe&gt; (xor 'false 'true)
true
</code></pre>
<p>With the <code>and</code> and <code>or</code> Boolean oprators, every argument is evaluated. To
accomodate situations where complex and possible expensive logical expressions
comprise the arguments to Boolean operators, short-circuit versions of these
functions are also provided:</p>
<ul>
<li>with <code>andalso</code>, returns as soon as the first <code>'false</code> is encountered;</li>
<li>with <code>orelse</code>, returns as soon as the first <code>'true</code> is encountered.</li>
</ul>
<p>To demonstrate this, we'll define a boolean function that prints to
<code>standard out</code> when it is evaluated:</p>
<pre><code class="language-lisp">(defun hey (x)
  (io:format &quot;Made it here!~n&quot;) x)
</code></pre>
<p>Short-circuit demonstration of <code>andalso</code>:</p>
<pre><code class="language-lisp">lfe&gt; (andalso 'true 'true 'false (hey 'true))
false
lfe&gt; (andalso 'false 'true 'true (hey 'true))
false
lfe&gt; (andalso 'true 'true 'true (hey 'true))
Made it here!
true
</code></pre>
<p>Short-circuit demonstration of <code>orelse</code>:</p>
<pre><code class="language-lisp">lfe&gt; (orelse 'false 'false 'true (hey 'true))
true
lfe&gt; (orelse 'true 'false 'false (hey 'true))
true
lfe&gt; (orelse 'false 'false 'false (hey 'true))
Made it here!
true
</code></pre>
<h2 id="predicates-3"><a class="header" href="#predicates-3">Predicates</a></h2>
<p>To test if a value is a Boolean, we will first include some code:</p>
<pre><code class="language-lisp">lfe&gt; (include-lib &quot;lfe/include/cl.lfe&quot;)
</code></pre>
<p>That adds Common Lisp inspired functions and macros to our REPL session.</p>
<pre><code class="language-lisp">lfe&gt; (booleanp 'true)
true
lfe&gt; (booleanp 'false)
true
lfe&gt; (booleanp 'arthur)
false
lfe&gt; (booleanp 42)
false
</code></pre>
<p>If the atom in question has been used in a function name definition:</p>
<p>If you prefer the Clojure-style of predicates:</p>
<pre><code class="language-lisp">lfe&gt; (include-lib &quot;lfe/include/clj.lfe&quot;)
lfe&gt; (boolean? 'true)
true
lfe&gt; (boolean? 'false)
true
lfe&gt; (boolean? 'arthur)
false
</code></pre>
<p>Of course there is always the Erlang predicate, usable without having to do any includes:</p>
<pre><code class="language-lisp">lfe&gt; (is_boolean 'true)
true
lfe&gt; (is_boolean 'false)
true
lfe&gt; (is_boolean 'arthur)
false
</code></pre>
<p>Note that, since LFE Booleans are also atoms, these are valid as well:</p>
<pre><code class="language-lisp">lfe&gt; (atomp 'true)
true
lfe&gt; (atom? 'false)
true
lfe&gt; (is_atom 'true)
true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="characters"><a class="header" href="#characters">Characters</a></h1>
<p>Characters in LFE Are represented internally by integers, however a literal
syntax is offered for convenience:</p>
<pre><code class="language-lisp">lfe&gt; #\a
97
lfe&gt; #\A
65
lfe&gt; #\√º
252
lfe&gt; #\√Ü
198
</code></pre>
<h2 id="converting-2"><a class="header" href="#converting-2">Converting</a></h2>
<p>Since a character literal and integer are the same thing as far as LFE is
concerned, there is no such thing as converting between a &quot;char&quot; and &quot;ord&quot; like
there is in some other languages.</p>
<p>However, one can format an integer as a string by telling the class of <code>format</code>
functions that the input is &quot;character&quot; type:</p>
<pre><code class="language-lisp">lfe&gt; (io_lib:format &quot;~c&quot; `(198))
&quot;√Ü&quot;
</code></pre>
<p>For merely printing to <code>standard out</code> instead of returning a value, one may
use:</p>
<pre><code class="language-lisp">lfe&gt; (lfe_io:format &quot;~c~n&quot; `(198))
√Ü
ok
lfe&gt; (io:format &quot;~c~n&quot; `(198))
√Ü
ok
</code></pre>
<h2 id="operators-2"><a class="header" href="#operators-2">Operators</a></h2>
<p>All operations that are valid for integers are valid for characters.</p>
<h2 id="predicates-4"><a class="header" href="#predicates-4">Predicates</a></h2>
<p>All predicates that are valid for integers are valid for characters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types-1"><a class="header" href="#primitive-types-1">Primitive Types</a></h1>
<p>This chapter covers the basic types of data available to LFE, upon which
primatives rest all LFE libraries and applications.</p>
<ul>
<li>Integers</li>
<li>Floats</li>
<li>Atoms</li>
<li>Booleans</li>
<li>Characters</li>
</ul>
<p>Each of these types has an LFE test function of the form <code>TYPENAMEp</code> (which
wrap the respective Erlang <code>is_TYPENAME</code> function). These are used to perform
type checks (especially common in guard expressions). These predicate functions
will be covered in their respective type sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lists"><a class="header" href="#lists">Lists</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes-and-binaries"><a class="header" href="#bytes-and-binaries">Bytes and Binaries</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-lists"><a class="header" href="#property-lists">Property Lists</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maps"><a class="header" href="#maps">Maps</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dicts"><a class="header" href="#dicts">Dicts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="records"><a class="header" href="#records">Records</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-sequence-functions"><a class="header" href="#generic-sequence-functions">Generic Sequence Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evaluation"><a class="header" href="#evaluation">Evaluation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-of-control"><a class="header" href="#flow-of-control">Flow of Control</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processes"><a class="header" href="#processes">Processes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messages-and-their-passing"><a class="header" href="#messages-and-their-passing">Messages and Their Passing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objects-and-flavors"><a class="header" href="#objects-and-flavors">Objects and Flavors</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io"><a class="header" href="#io">I/O</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accessing-files"><a class="header" href="#accessing-files">Accessing Files</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripting-with-lfe"><a class="header" href="#scripting-with-lfe">Scripting with LFE</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-lfe-projects"><a class="header" href="#creating-lfe-projects">Creating LFE Projects</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-rebar3"><a class="header" href="#using-rebar3">Using rebar3</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-layout-conventions"><a class="header" href="#project-layout-conventions">Project Layout Conventions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors-and-debugging"><a class="header" href="#errors-and-debugging">Errors and Debugging</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-unit-tests"><a class="header" href="#writing-unit-tests">Writing Unit Tests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-common-test-framework"><a class="header" href="#the-common-test-framework">The Common Test Framework</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-propr-test-framework"><a class="header" href="#the-propr-test-framework">The Propr Test Framework</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-compiler"><a class="header" href="#the-compiler">The Compiler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distributed-lfe"><a class="header" href="#distributed-lfe">Distributed LFE</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ports-and-port-drivers"><a class="header" href="#ports-and-port-drivers">Ports and Port Drivers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="servers"><a class="header" href="#servers">Servers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clients"><a class="header" href="#clients">Clients</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otp-behaviours"><a class="header" href="#otp-behaviours">OTP Behaviours</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applications"><a class="header" href="#applications">Applications</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="releases"><a class="header" href="#releases">Releases</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tables-and-databases"><a class="header" href="#tables-and-databases">Tables and Databases</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-otp-project"><a class="header" href="#example-otp-project">Example OTP Project</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epilogue"><a class="header" href="#epilogue">Epilogue</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="afterword"><a class="header" href="#afterword">Afterword</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliography"><a class="header" href="#bibliography">Bibliography</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendices"><a class="header" href="#appendices">Appendices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-origins-of-lisp"><a class="header" href="#the-origins-of-lisp">The Origins of Lisp</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-origins-of-erlang"><a class="header" href="#the-origins-of-erlang">The Origins of Erlang</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-overview-of-lfe"><a class="header" href="#an-overview-of-lfe">An Overview of LFE</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versions"><a class="header" href="#versions">Versions</a></h1>
<h2 id="current"><a class="header" href="#current">Current</a></h2>
<p>The current version of the LFE MACHINE MANUAL is written against LFE 2.0-dev.</p>
<h2 id="previous"><a class="header" href="#previous">Previous</a></h2>
<p>After the LFE 2.0 release, you will see a link to content created as part of that effort here. At which point the &quot;Current&quot; version will be incremented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feedback-and-documantation-bugs"><a class="header" href="#feedback-and-documantation-bugs">Feedback and Documantation Bugs</a></h1>
<p>If you would like to provide feedback about this guide, we would welcome the
chance to improve the experience for everyone. Please
<a href="https://github.com/cnbbooks/lfe-manual/issues/new">create a ticket</a> in the
Github issue tracker. Be sure to give a full description so that we can best
help you!</p>
<div style="break-before: page; page-break-before: always;"></div><meta http-equiv="refresh" content="0; URL=http://docs.lfe.io/" />
<div style="break-before: page; page-break-before: always;"></div><meta http-equiv="refresh" content="0; URL=https://github.com/rust-lang/mdbook/" />

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->


                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">

        </nav>

    </div>


    <!-- Google Analytics Tag -->
    <script type="text/javascript">
        var localAddrs = ["localhost", "127.0.0.1", ""];

        // make sure we don't activate google analytics if the developer is
        // inspecting the book locally...
        if (localAddrs.indexOf(document.location.hostname) === -1) {
            (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date(); a = s.createElement(o),
                m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

            ga('create', 'UA-38274766-4', 'auto');
            ga('send', 'pageview');
        }
    </script>


    <script type="text/javascript">
        window.playground_copyable = true;
    </script>


    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->

    <script type="text/javascript">
        window.addEventListener('load', function () {
            window.setTimeout(window.print, 100);
        });
    </script>

</body>

</html>
