# Part VI - Tooling

The most elegant programming language in the world is only as powerful as the tools that support it. Part VI explores the ecosystem that transforms LFE from an interesting academic exercise into a practical platform for building real software. At the heart of this ecosystem lies rebar3, the de facto standard build tool for Erlang and LFE projects, extended with a comprehensive plugin that brings first-class LFE support to every aspect of the development lifecycle.

Rebar3 represents more than just a build system - it embodies the collective wisdom of the Erlang community about how software projects should be structured, built, tested, and deployed. Originally created to manage the complex dependencies and compilation requirements of Erlang applications, rebar3 has evolved into a sophisticated project management platform that handles everything from generating initial project scaffolding to creating production releases. The LFE plugin seamlessly integrates into this ecosystem, ensuring that LFE developers can leverage the same battle-tested workflows that have made Erlang development so productive.

The Quick Start section demonstrates how modern tooling can dramatically reduce the friction of getting started with a new language. What once required understanding complex compilation pipelines and dependency management can now be accomplished with a few simple commands. You'll go from an empty directory to a running LFE application in minutes, with a project structure that follows community conventions and includes everything needed for testing, documentation, and deployment.

The plugin reference reveals the depth of integration between LFE and the broader Erlang ecosystem. The rebar3 LFE plugin doesn't just compile LFE code - it understands LFE's unique characteristics and provides specialized support for features like macros, packages, and interactive development. Whether you're running unit tests with eunit, exploring code at the REPL, or building complex multi-application releases, the plugin ensures that LFE feels like a first-class citizen in the Erlang world.

Project creation commands showcase the flexibility of modern LFE development. Different project types - libraries, standalone applications, escripts, OTP applications, and full releases - each come with appropriate scaffolding and configuration. This isn't just convenience; it's the embodiment of best practices accumulated over years of real-world development. When you generate a new LFE project, you're not starting from scratch - you're beginning with a foundation that incorporates decades of lessons learned about how to structure maintainable, scalable software.

The testing integration deserves particular attention, as it demonstrates how tooling can elevate testing from an afterthought to a central part of the development process. The plugin supports multiple testing frameworks - eunit for traditional unit testing, ltest for LFE-specific testing patterns, and Common Test for integration and system testing. This multi-layered approach reflects the reality that different types of testing require different tools, and good tooling should make it easy to use the right tool for each job.
Running and deployment commands bridge the gap between development and production. The ability to run code directly from the build system, execute escripts, or start full releases provides a seamless transition from experimentation to deployment. Hot code loading and release management - capabilities that seem almost magical in other languages - become routine operations supported by simple commands.

Perhaps most importantly, Part VI demonstrates how good tooling preserves the interactive, exploratory nature of Lisp development while providing the structure needed for serious software engineering. The REPL integration ensures that you can always drop into an interactive session to explore ideas, test hypotheses, or debug problems. This combination of structure and flexibility exemplifies the LFE philosophy: powerful abstractions that don't constrain creativity.

By the end of Part VI, you'll have mastered not just the mechanics of LFE development, but the workflows that make LFE development productive and enjoyable. You'll understand how to leverage community conventions while maintaining the flexibility to adapt tools to your specific needs. Most importantly, you'll have the confidence that comes from working with mature, well-designed tools that scale from quick experiments to large, complex systems.
